# -*- generated by 1.0.9 -*-
import da
PatternExpr_1155 = da.pat.TuplePattern([da.pat.ConstantPattern('caught_up'), da.pat.FreePattern('new_hash'), da.pat.FreePattern('db')])
PatternExpr_1164 = da.pat.FreePattern('r_id')
PatternExpr_1192 = da.pat.ConstantPattern('get_public_key_maps')
PatternExpr_1196 = da.pat.FreePattern('p_id')
PatternExpr_1230 = da.pat.TuplePattern([da.pat.ConstantPattern('getConfig'), da.pat.FreePattern('p')])
PatternExpr_1237 = da.pat.FreePattern('client_id')
PatternExpr_1271 = da.pat.ConstantPattern('generate_keys')
PatternExpr_1275 = da.pat.FreePattern('client_id')
PatternExpr_1325 = da.pat.ConstantPattern('get_chain_info')
PatternExpr_1329 = da.pat.FreePattern('replica_id')
PatternExpr_1451 = da.pat.TuplePattern([da.pat.ConstantPattern('wedged_reply'), da.pat.FreePattern('rid'), da.pat.FreePattern('hist'), da.pat.FreePattern('cp')])
PatternExpr_1462 = da.pat.FreePattern('p_id')
PatternExpr_1489 = da.pat.TuplePattern([da.pat.ConstantPattern('reconfiguration'), da.pat.FreePattern('cc')])
PatternExpr_1495 = da.pat.FreePattern('p_id')
PatternExpr_1544 = da.pat.TuplePattern([da.pat.ConstantPattern('need_new_config'), da.pat.FreePattern('cfg')])
PatternExpr_1551 = da.pat.FreePattern('c_id')
_config_object = {}
import time
import sys
import logging
import nacl.encoding
import nacl.signing
replica = da.import_da('Replica')

class Olympus(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_0', PatternExpr_1155, sources=[PatternExpr_1164], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1154]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_1', PatternExpr_1192, sources=[PatternExpr_1196], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1191]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_2', PatternExpr_1230, sources=[PatternExpr_1237], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1229]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_3', PatternExpr_1271, sources=[PatternExpr_1275], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1270]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_4', PatternExpr_1325, sources=[PatternExpr_1329], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1324]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_5', PatternExpr_1451, sources=[PatternExpr_1462], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1450]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_6', PatternExpr_1489, sources=[PatternExpr_1495], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1488]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_7', PatternExpr_1544, sources=[PatternExpr_1551], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1543])])

    def setup(self, conf, cni, fc, cc, **rest_1803):
        super().setup(conf=conf, cni=cni, fc=fc, cc=cc, **rest_1803)
        self._state.conf = conf
        self._state.cni = cni
        self._state.fc = fc
        self._state.cc = cc
        self._state.replicas = {}
        self._state.clientKeyMap = {}
        self._state.replicaKeyMap = {}
        self._state.prikey = ''
        self._state.pubkey = ''
        self._state.client_num_id = self._state.cni
        self._state.failures = self._state.fc
        self._state.logger = None
        self._state.curr_config = self._state.cc
        self._state.reconfig_flag = 0
        self._state.wedged_replies = {}
        self._state.caught_up = 1
        self._state.caught_up_hash = {}
        self._state.caught_up_states = {}

    def run(self):
        self._state.logger = self.get_logger('olympus', (self._state.conf['test_case_name'] + '_o.txt'))
        self._state.logger.info(self._state.client_num_id)
        self._state.prikey = nacl.signing.SigningKey.generate()
        self._state.pubkey = self._state.prikey.verify_key
        self._state.logger.info('Created public and private keys for self')
        start_st = {}
        self.create_replicas(start_st)
        while True:
            super()._label('_st_label_369', block=False)
            _st_label_369 = 0
            while (_st_label_369 == 0):
                _st_label_369 += 1
                if (self._state.reconfig_flag == 1):
                    _st_label_369 += 1
                else:
                    super()._label('_st_label_369', block=True)
                    _st_label_369 -= 1
            else:
                if (_st_label_369 != 2):
                    continue
            if (_st_label_369 != 2):
                break
            super()._label('_st_label_376', block=False)
            _st_label_376 = 0
            while (_st_label_376 == 0):
                _st_label_376 += 1
                if (len(self._state.wedged_replies) == (len(self._state.replicas) - 1)):
                    _st_label_376 += 1
                else:
                    super()._label('_st_label_376', block=True)
                    _st_label_376 -= 1
            else:
                if (_st_label_376 != 2):
                    continue
            if (_st_label_376 != 2):
                break
            self._state.logger.info((str(self._id) + ' Reconfiguration underway'))
            self._state.logger.info((str(self._id) + ' Validating Individual histories'))
            for r in self._state.wedged_replies:
                h = self._state.wedged_replies[r][0]
                self._state.logger.info((((str(self._id) + ' History for : ') + str(r)) + ' is : %s'), h)
                prev = (- 1)
                for req in h:
                    if (prev == (- 1)):
                        prev = int(h[req].split(';')[1])
                    elif ((prev + 1) == int(h[req].split(';')[1])):
                        prev = int(h[req].split(';')[1])
                    else:
                        self.output("This replica doesn't have correct history")
            self._state.logger.info((str(self._id) + ' Getting highest checkpoint'))
            max_cp = (- 1)
            for r in self._state.wedged_replies:
                cp = self._state.wedged_replies[r][1]
                if (not (len(cp) == 0)):
                    cp_slot = list(cp)[0]
                else:
                    cp_slot = (- 1)
                if (max_cp < cp_slot):
                    max_cp = cp_slot
                self._state.logger.info(((((str(self._id) + ' Last Checkpoint for : ') + str(r)) + ' is : ') + str(cp_slot)))
            self._state.logger.info(((str(self._id) + ' Highest Checkpoint : ') + str(cp_slot)))
            self._state.logger.info((str(self._id) + ' Getting highest slot seen by replica'))
            h_slot = (- 1)
            h_s_rep = None
            for r in self._state.wedged_replies:
                h = self._state.wedged_replies[r][0]
                len_h = len(list(h))
                if (not (len_h == 0)):
                    last_os = h[list(h)[(len_h - 1)]]
                    lslot = int(last_os.split(';')[1])
                    if (h_slot < lslot):
                        h_slot = lslot
                        h_s_rep = r
                    self._state.logger.info(((((str(self._id) + ' Last os for ') + str(r)) + 'is : ') + last_os))
                    self._state.logger.info(((((str(self._id) + ' Last Slot seen by ') + str(r)) + 'is : ') + str(lslot)))
                else:
                    self._state.logger.info((((str(self._id) + ' ') + str(r)) + 'has completely truncated history'))
            inv_catchup = False
            if (not ((h_slot + 1) == max_cp)):
                self._state.logger.info(((((str(self._id) + ' The highest slot seen by a replica is ') + str(h_slot)) + ' seen by : ') + str(h_s_rep)))
                inv_catchup = True
            else:
                self._state.logger.info((str(self._id) + ' Catching up need not be done '))
                inv_catchup = False
            self._state.logger.info((str(self._id) + ' Beginning catch up process'))
            if (inv_catchup == True):
                for r in self._state.wedged_replies:
                    if (not (r == h_s_rep)):
                        longest_h = self._state.wedged_replies[h_s_rep][0]
                        cmp_h = self._state.wedged_replies[r][0]
                        cmp_s = list(self._state.wedged_replies[r][1])[0]
                        catch_up_hist = {}
                        h_f = 0
                        s_h = 0
                        t_h = 0
                        if (len(cmp_h) == 0):
                            if (cmp_s == max_cp):
                                (t_h == 1)
                                self.output('Has max checkpoint and completely truncated history')
                        for rid in longest_h:
                            if (s_h == 0):
                                if ((int(longest_h[rid].split(';')[1]) + 1) <= cmp_s):
                                    self.output(('skipping history ' + longest_h[rid]))
                                    continue
                                else:
                                    s_h = 1
                            if ((h_f == 0) and (rid in cmp_h)):
                                self.output(('both have ' + longest_h[rid]))
                                continue
                            else:
                                h_f = 1
                            if (h_f == 1):
                                catch_up_hist[rid] = longest_h[rid]
                        self._state.logger.info((((str(self._id) + ' Catchup instructions for ') + str(r)) + ' are: %s'), catch_up_hist)
                        self._state.logger.info(((str(self._id) + ' Sending catch up instruction to : ') + str(r)))
                        self.send(('catch_up', catch_up_hist), to=r)
                        self.send(('catch_up', {}), to=h_s_rep)
            else:
                catch_up_hist = {}
                for r in self._state.wedged_replies:
                    self.send(('catch_up', catch_up_hist), to=r)
            super()._label('_st_label_965', block=False)
            _st_label_965 = 0
            while (_st_label_965 == 0):
                _st_label_965 += 1
                if (self._state.caught_up == len(self._state.wedged_replies)):
                    _st_label_965 += 1
                else:
                    super()._label('_st_label_965', block=True)
                    _st_label_965 -= 1
            else:
                if (_st_label_965 != 2):
                    continue
            if (_st_label_965 != 2):
                break
            self._state.logger.info((str(self._id) + ' Received all caught up messages'))
            self._state.logger.info((str(self._id) + ' Verifying new Hashes'))
            hash_f = 0
            correct_h = 0
            for r in self._state.caught_up_hash:
                if (hash_f == 0):
                    temp = self._state.caught_up_hash[r]
                    temp_s = self._state.caught_up_states[r]
                    correct_h = (correct_h + 1)
                    hash_f = 1
                elif (temp == self._state.caught_up_hash[r]):
                    correct_h = (correct_h + 1)
                    temp_s = self._state.caught_up_states[r]
            if (correct_h == (int(self._state.conf['t']) + 1)):
                self._state.logger.info((str(self._id) + 'Found enough correct hashes to start reconfiguration'))
                self._state.logger.info((str(self._id) + 'Starting new configuration'))
                self._state.curr_config = (self._state.curr_config + 1)
                self.create_replicas(temp_s)
                self._state.logger.info((str(self._id) + 'Reconfiguration complete'))
                for c_id in self._state.clientKeyMap:
                    self._state.logger.info(((str(self._id) + 'Sending new configuration to client : ') + str(c_id)))
                    self.send(('new_config', self._state.curr_config, self._state.replicaKeyMap, self._state.replicas), to=c_id)
                self._state.reconfig_flag = 0
            else:
                self._state.logger.info((str(self._id) + "Couldn't get enough correct hashes.. Ideally get new quorum"))

    def get_logger(self, name, filename):
        formatter = logging.Formatter(fmt='%(asctime)s %(levelname)-8s %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
        hld = logging.FileHandler(filename, mode='a')
        hld.setFormatter(formatter)
        self._state.logger = logging.getLogger(name)
        self._state.logger.setLevel(logging.DEBUG)
        self._state.logger.addHandler(hld)
        return self._state.logger

    def create_replicas(self, start_st):
        num_replicas = ((2 * self._state.conf['t']) + 1)
        self._state.logger.info(('Creating replicas. Number = ' + str(num_replicas)))
        self._state.replicas = self.new(replica.Replica, num=num_replicas)
        self.output(self._state.replicas)
        cnt = 0
        self._state.replicaKeyMap = {}
        if (self._state.curr_config in self._state.failures):
            failureCases = self._state.failures[self._state.curr_config]
        else:
            failureCases = {}
        for r in self._state.replicas:
            self._state.logger.info(('setting up keys and starting replica: ' + str(r)))
            pri_key = nacl.signing.SigningKey.generate()
            pub_key = pri_key.verify_key
            self._state.replicaKeyMap[r] = pub_key
            if (cnt == 0):
                if (cnt in failureCases):
                    self._setup(r, (self._state.conf, True, False, pri_key, self._state.cni, failureCases[cnt], self._state.curr_config, start_st, self._id))
                else:
                    self._setup(r, (self._state.conf, True, False, pri_key, self._state.cni, None, self._state.curr_config, start_st, self._id))
            elif (cnt == (len(self._state.replicas) - 1)):
                if (cnt in failureCases):
                    self._setup(r, (self._state.conf, False, True, pri_key, self._state.cni, failureCases[cnt], self._state.curr_config, start_st, self._id))
                else:
                    self._setup(r, (self._state.conf, False, True, pri_key, self._state.cni, None, self._state.curr_config, start_st, self._id))
            elif (cnt in failureCases):
                self._setup(r, (self._state.conf, False, False, pri_key, self._state.cni, failureCases[cnt], self._state.curr_config, start_st, self._id))
            else:
                self._setup(r, (self._state.conf, False, False, pri_key, self._state.cni, None, self._state.curr_config, start_st, self._id))
            self._start(r)
            cnt = (cnt + 1)

    def _Olympus_handler_1154(self, new_hash, db, r_id):
        self._state.caught_up = (self._state.caught_up + 1)
        self._state.caught_up_hash[r_id] = new_hash
        self._state.caught_up_states[r_id] = db
    _Olympus_handler_1154._labels = None
    _Olympus_handler_1154._notlabels = None

    def _Olympus_handler_1191(self, p_id):
        self._state.logger.info(('received get_public_key_maps message from: ' + str(p_id)))
        self._state.logger.info(('sending public key maps to :' + str(p_id)))
        self.send(('public_key_maps', self._state.clientKeyMap, self._state.replicaKeyMap), to=p_id)
    _Olympus_handler_1191._labels = None
    _Olympus_handler_1191._notlabels = None

    def _Olympus_handler_1229(self, p, client_id):
        self._state.logger.info(('received getConfig message from :' + str(client_id)))
        self.output('Sending current config to : ', client_id)
        self._state.logger.info(('Sending current config to: ' + str(client_id)))
        self.send(('currentConfig', self._state.replicas), to=client_id)
    _Olympus_handler_1229._labels = None
    _Olympus_handler_1229._notlabels = None

    def _Olympus_handler_1270(self, client_id):
        self._state.logger.info(('received generate_keys message from: ' + str(client_id)))
        pri_key = nacl.signing.SigningKey.generate()
        pub_key = pri_key.verify_key
        self._state.clientKeyMap[client_id] = pub_key
        self._state.logger.info(('generating and sending private key to : ' + str(client_id)))
        self.send(('generated_key', pri_key), to=client_id)
    _Olympus_handler_1270._labels = None
    _Olympus_handler_1270._notlabels = None

    def _Olympus_handler_1324(self, replica_id):
        self._state.logger.info(('received get_chain_info message from : ' + str(replica_id)))
        rep = list(self._state.replicas)
        headReplica = rep[0]
        for i in range(0, len(rep)):
            if (rep[i] == replica_id):
                break
        if (i == 0):
            self._state.logger.info(('sending back chain info to ' + str(replica_id)))
            self.send(('val_chain_info', None, rep[(i + 1)], headReplica), to=replica_id)
        elif (i == (len(rep) - 1)):
            self._state.logger.info(('sending back chain info to ' + str(replica_id)))
            self.send(('val_chain_info', rep[(i - 1)], None, headReplica), to=replica_id)
        else:
            self._state.logger.info(('sending back chain info to ' + str(replica_id)))
            self.send(('val_chain_info', rep[(i - 1)], rep[(i + 1)], headReplica), to=replica_id)
    _Olympus_handler_1324._labels = None
    _Olympus_handler_1324._notlabels = None

    def _Olympus_handler_1450(self, rid, hist, cp, p_id):
        self._state.logger.info(((str(self._id) + ' received wedged reply from ') + str(p_id)))
        self._state.wedged_replies[rid] = [hist, cp]
    _Olympus_handler_1450._labels = None
    _Olympus_handler_1450._notlabels = None

    def _Olympus_handler_1488(self, cc, p_id):
        if ((self._state.curr_config == cc) and (self._state.reconfig_flag == 0)):
            for r in self._state.replicas:
                self.send('wedge_request', to=r)
            self._state.reconfig_flag = 1
            self._state.logger.info(((str(self._id) + ' Received reconfiguration request from ') + str(p_id)))
        else:
            self.output('Reconfiguration underway for the received config value. Ignoring request')
    _Olympus_handler_1488._labels = None
    _Olympus_handler_1488._notlabels = None

    def _Olympus_handler_1543(self, cfg, c_id):
        if (self._state.curr_config > cfg):
            self.send(('new_config', self._state.curr_config, self._state.replicaKeyMap, self._state.replicas), to=c_id)
    _Olympus_handler_1543._labels = None
    _Olympus_handler_1543._notlabels = None
