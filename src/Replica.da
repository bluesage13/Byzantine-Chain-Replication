import time

class Replica(process):

  def setup(conf, head, tail, pri_key, olympus):
    self.db = {}
    self.state = "ACTIVE"
    self.isHead = head
    self.isTail = tail
    self.headReplica = None
    self.successor = self
    self.predecessor = self
    self.History = {}
    self.current_slot = 0
    self.resultCache = {}
    self.retran_flag = 0
    self.ReTransmittedRequest = []
    self.privateKey =  pri_key
    self.replicaKM = {}
    self.clientKM = {}
    self.flag = 0


  def run():
    send(('get_chain_info'), to = olympus)
    await(self.flag == 1)
    self.flag = 0
    send(('get_public_key_maps'), to = olympus)
    await(False)

  def get_slot_number():
    s = self.current_slot
    self.current_slot = self.current_slot + 1
    return s

  def checkIfRidPresentInHistory(requestID):
    if requestID in self.History:
      return True
    return False

  def orderCommand(s, o, args):
    os = str(self);
    os = os + ';' + str(s)
    os = os + ';' + o
    for arg in args:
      os = os + ';' + arg
    for key in self.History:
      if (self.History[key] == os):
        #become immutable and send erconfig
        return "error"
    return os

  def verifyOrderProof(orderProof, requestID):
    orderStatements = orderProof[requestID]
    #for i in range(0, (len(orderStatements) - 1)):
    #  if( orderStatements[i].split(';')[1:] != orderStatements[i+1].split(';')[1:] ):
    #    return False
    #return True
    i = 0
    for key in self.replicaKM:
      if(i < len(orderStatements)):
        try:
          replicaKM[key].verify(orderStatements[i])
        except:
          output("Bad or corrupted key.")
          return False
      else:
        return True
        break
      i = i + 1

  def receive(msg = ('public_key_maps', cKM, rKM), from_ = olympus):
    self.replicaKM = rKM
    self.clientKM = cKM

  def encodeStatement(statement):
    enc_s = self.privateKey.sign(bytes(statement,'utf-8'))
    return enc_s

  def receive(msg = ('put', k_v, client_id, requestID), from_=p_id):
    if(self.state == "ACTIVE"):
      if(checkIfRidPresentInHistory(requestID) == False):
        if(self.isHead):
          slot = get_slot_number()
          os = orderCommand(slot, 'put', k_v)
          if(os != 'error'):
            self.History[requestID] = os
          enc_os = encodeStatement(os)
          self.db[k_v[0]] = k_v[1]
          orderProof = {}
          orderProof[requestID] = [enc_os]
          result_statement = ""
          result_statement = encodeStatement(str(self) + ";" + "OK")
          resultProof = {}
          resultProof[requestID] = [result_statement]
          OrderShuttle = [orderProof, resultProof]
          send(('put', k_v, client_id, requestID, OrderShuttle), to = self.successor)
        else:
          #this is a retransmission case handle it accordingly
          output("replica says retransmissoin")

      else:
        if(requestID in self.resultCache) :
          send(('put_result', {requestID : self.resultCache[requestID]}, requestID), to = client_id)

        else:
          self.retran_flag = 0
          self.ReTransmittedRequest.append(requestID)
          if await(self.retran_flag == 1):
            self.retran_flag = 0
          elif timeout(conf['head_timeout']/1000):
            output("Retransmission timeout. Needs reconfiguration")

    else:
      output("Replica is immutable")

  def receive(msg = ('put', k_v, client_id, requestID, OrderShuttle), from_=p_id):
    if(isHead != True):
      if(verifyOrderProof(OrderShuttle[0], requestID) == True):
        slot = get_slot_number()
        os = orderCommand(slot, 'put', k_v)
        if(os != 'error'):
          self.History[requestID] = os
        enc_os = encodeStatement(os)
        self.db[k_v[0]] = k_v[1]
        OrderShuttle[0][requestID].append(enc_os)
        result_statement = ""
        result_statement = encodeStatement(str(self) + ";" + "OK")
        OrderShuttle[1][requestID].append(result_statement)
        if(isTail != True):
          send(('put', k_v, client_id, requestID, OrderShuttle), to = self.successor)
        else:
          send(('put_result', OrderShuttle[1], requestID), to = client_id)
          send(('result_back', OrderShuttle[1], requestID), to = self.predecessor)
      else:
        output("Dropping invalid request")

  def receive(msg=('get', key, client_id, requestID), from_=p_id):
    if(self.state == "ACTIVE"):
      if(checkIfRidPresentInHistory(requestID) == False):
        if(self.isHead):
          slot = get_slot_number()
          os = orderCommand(slot, 'get', [key])
          if(os != 'error'):
            self.History[requestID] = os
          enc_os = encodeStatement(os)
          orderProof = {}
          orderProof[requestID] = [enc_os]
          result_statement = ""
          if(key in self.db):
            result_statement = encodeStatement(str(self) + ";" + self.db[key])
          else:
            result_statement = encodeStatement(str(self) + ";")
          resultProof = {}
          resultProof[requestID] = [result_statement]
          OrderShuttle = [orderProof, resultProof]
          send(('get', key, client_id, requestID, OrderShuttle), to = self.successor)
        else:
          #this is a retransmission case handle it accordingly
          x = 1

      else:
        output("operation already present in history")
        if(requestID in self.resultCache) :
          send(('get_result', {requestID : self.resultCache[requestID]}, requestID), to = client_id)

        else:
          self.retran_flag = 0
          self.ReTransmittedRequest.append(requestID)
          if await(self.retran_flag == 1):
            self.retran_flag = 0
          elif timeout(conf['head_timeout']/1000):
            output("Retransmission timeout. Needs reconfiguration")

    else:
      output("Replica is immutable")

  def receive(msg = ('get', key, client_id, requestID, OrderShuttle), from_=p_id):
    if(isHead != True):
      if(verifyOrderProof(OrderShuttle[0], requestID) == True):
        slot = get_slot_number()
        os = orderCommand(slot, 'get', [key])
        if(os != 'error'):
          self.History[requestID] = os
        enc_os = encodeStatement(os)
        OrderShuttle[0][requestID].append(enc_os)
        result_statement = ""
        if(key in self.db):
          result_statement = encodeStatement(str(self) + ";" + self.db[key])
        else:
          result_statement = encodeStatement(str(self) + ";")
        OrderShuttle[1][requestID].append(result_statement)
        if(isTail != True):
          send(('get', key, client_id, requestID, OrderShuttle), to = self.successor)
        else:
          send(('get_result', OrderShuttle[1], requestID), to = client_id)
          send(('result_back', OrderShuttle[1], requestID), to = self.predecessor)
      else:
        output("Dropping invalid request")

  def receive(msg=('slice', args, client_id, requestID), from_=p_id):
    if(self.state == "ACTIVE"):
      if(checkIfRidPresentInHistory(requestID) == False):
        if(self.isHead):
          slot = get_slot_number()
          os = orderCommand(slot, 'slice', args)
          if(os != 'error'):
            self.History[requestID] = os
          orderProof = {}
          enc_os = encodeStatement(os)
          orderProof[requestID] = [enc_os]
          result_statement = ""

          (start, end) = args[1].split(':')
          if(args[0] in self.db):
            val = self.db[args[0]]
            if((int(start) >= 0) and (int(end) <= len(val))):
              val = val[int(start):int(end)]
              self.db[args[0]] = val
              result_statement = encodeStatement(str(self) + ';' + "OK")
            else:
              result_statement = encodeStatement(str(self) + ';' + "FAIL")
          else:
            result_statement = encodeStatement(str(self) + ';' + "FAIL")

          resultProof = {}
          resultProof[requestID] = [result_statement]
          OrderShuttle = [orderProof, resultProof]
          send(('slice', args, client_id, requestID, OrderShuttle), to = self.successor)
        else:
          #this is a retransmission case handle it accordingly
          x = 1

      else:
        output("Already Present in History")
        if(requestID in self.resultCache) :
          send(('slice_result', {requestID : self.resultCache[requestID]}, requestID), to = client_id)

        else:
          self.retran_flag = 0
          self.ReTransmittedRequest.append(requestID)
          if await(self.retran_flag == 1):
            self.retran_flag = 0
          elif timeout(conf['head_timeout']/1000):
            output("Retransmission timeout. Needs reconfiguration")

    else:
      output("Replica is immutable")

  def receive(msg=('slice', args, client_id, requestID, OrderShuttle), from_=p_id):
    if(isHead != True):
      if(verifyOrderProof(OrderShuttle[0], requestID) == True):
        slot = get_slot_number()
        os = orderCommand(slot, 'slice', args)
        if(os != 'error'):
          self.History[requestID] = os
        enc_os = encodeStatement(os)
        OrderShuttle[0][requestID].append(enc_os)
        result_statement = ""

        (start, end) = args[1].split(':')
        if(args[0] in self.db):
          val = self.db[args[0]]
          if((int(start) >= 0) and (int(end) <= len(val))):
            val = val[int(start):int(end)]
            self.db[args[0]] = val
            result_statement = encodeStatement(str(self) + ';' + "OK")
          else:
            result_statement = encodeStatement(str(self) + ';' + "FAIL")
        else:
          result_statement = encodeStatement(str(self) + ';' + "FAIL")

        OrderShuttle[1][requestID].append(result_statement)
        if(isTail != True):
          send(('slice', args, client_id, requestID, OrderShuttle), to = self.successor)
        else:
          send(('slice_result', OrderShuttle[1], requestID), to = client_id)
          send(('result_back', OrderShuttle[1], requestID), to = self.predecessor)
      else:
        output("Dropping invalid request")

  def receive(msg=('append', args, client_id, requestID), from_=p_id):
    if(self.state == "ACTIVE"):
      if(checkIfRidPresentInHistory(requestID) == False):
        if(self.isHead):
          slot = get_slot_number()
          os = orderCommand(slot, 'append', args)
          if(os != 'error'):
            self.History[requestID] = os
          orderProof = {}
          enc_os = encodeStatement(os)
          orderProof[requestID] = [enc_os]
          result_statement = ""
          if(args[0] in self.db):
            val = self.db[args[0]]
            val = val + " " + args[1]
            self.db[args[0]] = val
            result_statement = encodeStatement(str(self) + ';' + "OK")
          else:
            result_statement = encodeStatement(str(self) + ';' + "FAIL")
          resultProof = {}
          resultProof[requestID] = [result_statement]
          OrderShuttle = [orderProof, resultProof]
          send(('append', args, client_id, requestID, OrderShuttle), to = self.successor)
        else:
          #this is a retransmission case handle it accordingly
          x = 1

      else:
        output("operation already present in history")
        if(requestID in self.resultCache) :
          send(('get_result', {requestID : self.resultCache[requestID]}, requestID), to = client_id)

        else:
          self.retran_flag = 0
          self.ReTransmittedRequest.append(requestID)
          if await(self.retran_flag == 1):
            self.retran_flag = 0
          elif timeout(conf['head_timeout']/1000):
            output("Retransmission timeout. Needs reconfiguration")

    else:
      output("Replica is immutable")

  def receive(msg=('append', args, client_id, requestID, OrderShuttle), from_=p_id):
    if(isHead != True):
      if(verifyOrderProof(OrderShuttle[0], requestID) == True):
        slot = get_slot_number()
        os = orderCommand(slot, 'append', args)
        if(os != 'error'):
          self.History[requestID] = os
        enc_os = encodeStatement(os)
        OrderShuttle[0][requestID].append(enc_os)
        result_statement = ""
        if(args[0] in self.db):
          val = self.db[args[0]]
          val = val + " " + args[1]
          self.db[args[0]] = val
          result_statement = encodeStatement(str(self) + ';' + "OK")
        else:
          result_statement = encodeStatement(str(self) + ';' + "FAIL")
        OrderShuttle[1][requestID].append(result_statement)
        if(isTail != True):
          send(('append', args, client_id, requestID, OrderShuttle), to = self.successor)
        else:
          send(('append_result', OrderShuttle[1], requestID), to = client_id)
          send(('result_back', OrderShuttle[1], requestID), to = self.predecessor)
      else:
        output("Dropping invalid request")

  def receive(msg = ('get_dict'), from_ = client_id):
    send(('dict_reply', self.db), to = client_id)

  def receive(msg = ('result_back', result_shuttle, requestID), from_ = p_id):
    cond = True
    resultStatements = result_shuttle[requestID]
    i = 0
    for key in self.replicaKM:
      try:
        self.replicaKM[key].verify(resultStatement[i])
        i = i + 1
      except:
        cond = False
        break

    if(cond == True):
      if(requestID in self.ReTransmittedRequest):
        output("Sending back the response of retransmitted request to : CLIENT")
        self.resultCache[requestID] = result_shuttle[requestID]
        if(isHead == False):
          send(('result_back', result_shuttle, requestID), to = self.predecessor)
        self.retran_flag = 1
      else:
        self.resultCache[requestID] = result_shuttle[requestID]
        if(isHead == False):
          send(('result_back', result_shuttle, requestID), to = self.predecessor)
    #for key in self.resultCache :
    #  output(key, self.resultCache[key])

  def receive(msg=('val_chain_info', p, s, head), from_ = olympus):
    self.successor = s
    self.predecessor = p
    self.headReplica = head
    self.flag = 1
