# -*- generated by 1.0.9 -*-
import da
PatternExpr_1591 = da.pat.TuplePattern([da.pat.ConstantPattern('public_key_maps'), da.pat.FreePattern('cKM'), da.pat.FreePattern('rKM')])
PatternExpr_1600 = da.pat.FreePattern('olympus')
PatternExpr_1769 = da.pat.TuplePattern([da.pat.ConstantPattern('completed_cp'), da.pat.FreePattern('cp_slot'), da.pat.FreePattern('checkpoint_proof')])
PatternExpr_1778 = da.pat.FreePattern('p_id')
PatternExpr_1836 = da.pat.TuplePattern([da.pat.ConstantPattern('checkpoint'), da.pat.FreePattern('cp_slot'), da.pat.FreePattern('checkpoint_proof')])
PatternExpr_1845 = da.pat.FreePattern('p_id')
PatternExpr_1969 = da.pat.TuplePattern([da.pat.ConstantPattern('put'), da.pat.FreePattern('k_v'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID')])
PatternExpr_1980 = da.pat.FreePattern('p_id')
PatternExpr_2469 = da.pat.TuplePattern([da.pat.ConstantPattern('put'), da.pat.FreePattern('k_v'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID'), da.pat.FreePattern('OrderShuttle')])
PatternExpr_2482 = da.pat.FreePattern('p_id')
PatternExpr_2917 = da.pat.TuplePattern([da.pat.ConstantPattern('get'), da.pat.FreePattern('key'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID')])
PatternExpr_2928 = da.pat.FreePattern('p_id')
PatternExpr_3390 = da.pat.TuplePattern([da.pat.ConstantPattern('get'), da.pat.FreePattern('key'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID'), da.pat.FreePattern('OrderShuttle')])
PatternExpr_3403 = da.pat.FreePattern('p_id')
PatternExpr_3827 = da.pat.TuplePattern([da.pat.ConstantPattern('slice'), da.pat.FreePattern('args'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID')])
PatternExpr_3838 = da.pat.FreePattern('p_id')
PatternExpr_4402 = da.pat.TuplePattern([da.pat.ConstantPattern('slice'), da.pat.FreePattern('args'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID'), da.pat.FreePattern('OrderShuttle')])
PatternExpr_4415 = da.pat.FreePattern('p_id')
PatternExpr_4918 = da.pat.TuplePattern([da.pat.ConstantPattern('append'), da.pat.FreePattern('args'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID')])
PatternExpr_4929 = da.pat.FreePattern('p_id')
PatternExpr_5420 = da.pat.TuplePattern([da.pat.ConstantPattern('append'), da.pat.FreePattern('args'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID'), da.pat.FreePattern('OrderShuttle')])
PatternExpr_5433 = da.pat.FreePattern('p_id')
PatternExpr_5898 = da.pat.ConstantPattern('get_dict')
PatternExpr_5902 = da.pat.FreePattern('client_id')
PatternExpr_5915 = da.pat.TuplePattern([da.pat.ConstantPattern('checkpoint'), da.pat.FreePattern('cp_sn'), da.pat.FreePattern('checkpoint_proof')])
PatternExpr_5924 = da.pat.FreePattern('p_id')
PatternExpr_5952 = da.pat.TuplePattern([da.pat.ConstantPattern('result_back'), da.pat.FreePattern('result_shuttle'), da.pat.FreePattern('requestID'), da.pat.FreePattern('clientID')])
PatternExpr_5963 = da.pat.FreePattern('p_id')
PatternExpr_6091 = da.pat.TuplePattern([da.pat.ConstantPattern('val_chain_info'), da.pat.FreePattern('p'), da.pat.FreePattern('s'), da.pat.FreePattern('head')])
PatternExpr_6101 = da.pat.FreePattern('olympus')
PatternExpr_6127 = da.pat.ConstantPattern('wedge_request')
PatternExpr_6131 = da.pat.FreePattern('olym')
PatternExpr_6166 = da.pat.ConstantPattern('get_running_state')
PatternExpr_6170 = da.pat.FreePattern('olymp')
PatternExpr_6188 = da.pat.TuplePattern([da.pat.ConstantPattern('catch_up'), da.pat.FreePattern('catch_up_hist')])
PatternExpr_6195 = da.pat.FreePattern('olym')
PatternExpr_6442 = da.pat.ConstantPattern('reconfig')
PatternExpr_6446 = da.pat.FreePattern('client')
_config_object = {}
import time
import collections
import sys
import logging
import nacl.hash
import os

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_1591, sources=[PatternExpr_1600], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1590]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_1769, sources=[PatternExpr_1778], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1768]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_1836, sources=[PatternExpr_1845], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1835]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_1969, sources=[PatternExpr_1980], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1968]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_2469, sources=[PatternExpr_2482], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2468]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_2917, sources=[PatternExpr_2928], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2916]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_3390, sources=[PatternExpr_3403], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3389]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_3827, sources=[PatternExpr_3838], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3826]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_4402, sources=[PatternExpr_4415], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4401]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_9', PatternExpr_4918, sources=[PatternExpr_4929], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4917]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_10', PatternExpr_5420, sources=[PatternExpr_5433], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5419]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_11', PatternExpr_5898, sources=[PatternExpr_5902], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5897]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_12', PatternExpr_5915, sources=[PatternExpr_5924], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5914]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_13', PatternExpr_5952, sources=[PatternExpr_5963], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5951]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_14', PatternExpr_6091, sources=[PatternExpr_6101], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6090]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_15', PatternExpr_6127, sources=[PatternExpr_6131], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6126]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_16', PatternExpr_6166, sources=[PatternExpr_6170], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6165]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_17', PatternExpr_6188, sources=[PatternExpr_6195], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6187]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_18', PatternExpr_6442, sources=[PatternExpr_6446], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6441])])

    def setup(self, conf, head, tail, pri_key, cni, failures, cc, start_st, olympus, **rest_6888):
        super().setup(conf=conf, head=head, tail=tail, pri_key=pri_key, cni=cni, failures=failures, cc=cc, start_st=start_st, olympus=olympus, **rest_6888)
        self._state.conf = conf
        self._state.head = head
        self._state.tail = tail
        self._state.pri_key = pri_key
        self._state.cni = cni
        self._state.failures = failures
        self._state.cc = cc
        self._state.start_st = start_st
        self._state.olympus = olympus
        self._state.db = self._state.start_st
        self._state.state = 'ACTIVE'
        self._state.isHead = self._state.head
        self._state.isTail = self._state.tail
        self._state.headReplica = None
        self._state.successor = self._id
        self._state.predecessor = self._id
        self._state.History = {}
        self._state.current_slot = 0
        self._state.resultCache = {}
        self._state.retran_flag = 0
        self._state.ReTransmittedRequest = []
        self._state.privateKey = self._state.pri_key
        self._state.replicaKM = {}
        self._state.clientKM = {}
        self._state.flag = 0
        self._state.client_num_id = self._state.cni
        self._state.failures = self._state.failures
        self._state.failure_map = collections.defaultdict(dict)
        self._state.fail_flag = False
        self._state.curr_fail_op = ''
        self._state.logger = None
        self._state.cp_interval = (- 1)
        self._state.cccslot = (- 1)
        self._state.chcslot = (- 1)
        self._state.h_cp_proof = {}
        self._state.c_cp_proof = {}
        self._state.hasher = nacl.hash.sha256
        self._state.mod_cp_hash = ''
        self._state.send_cp = 0
        self._state.curr_config = self._state.cc
        self._state.should_term = False
        self._state.client_request_t = {}
        self._state.forwarded_request_t = {}
        self._state.shuttle_t = {}
        self._state.result_shuttle_t = {}
        self._state.wedge_request_t = {}
        self._state.new_config_t = {}
        self._state.checkpt_t = {}
        self._state.comp_cp_t = {}
        self._state.get_run_st_t = {}
        self._state.catch_up_t = {}
        self._state.wr_cnt = 0
        self._state.nc_cnt = 0
        self._state.cp_cnt = 0
        self._state.ccp_cnt = 0
        self._state.grs_cnt = 0
        self._state.cu_cnt = 0
        self._state.th_num = 0
        self._state.sleep_t = 0
        self._state.crash_f = False
        self._state.th_flag = False
        self._state.sl_flag = False
        self._state.dr_flag = False
        self._state.is_flag = False
        self._state.eo_flag = False
        self._state.ios_flag = False
        self._state.irs_flag = False
        self._state.dcs_flag = False

    def run(self):
        logger_file_name = ((self._state.conf['test_case_name'] + str(self._id).split(':')[1]) + '_r.txt')
        self._state.cp_interval = int(self._state.conf['checkpt_interval'])
        self._state.logger = self.get_logger('replica', logger_file_name)
        self._state.logger.info((((str(self._id) + ' Created for configuration : ') + str(self._state.curr_config)) + ' with state : %s'), self._state.db)
        self._state.logger.info((str(self._id) + ' Getting chain info from olympus'))
        self.send('get_chain_info', to=self._state.olympus)
        super()._label('_st_label_680', block=False)
        _st_label_680 = 0
        while (_st_label_680 == 0):
            _st_label_680 += 1
            if (self._state.flag == 1):
                _st_label_680 += 1
            else:
                super()._label('_st_label_680', block=True)
                _st_label_680 -= 1
        self._state.flag = 0
        self._state.logger.info((str(self._id) + ' getting public key maps from olympus'))
        self.send('get_public_key_maps', to=self._state.olympus)
        self._state.logger.info((str(self._id) + ' Parsing failures'))
        self.parse_failures()
        self._state.logger.info(((str(self._id) + ' ') + str(self._state.failures)))
        self.set_fail_flags('nc')
        super()._label('_st_label_736', block=False)
        _st_label_736 = 0
        while (_st_label_736 == 0):
            _st_label_736 += 1
            if (self._state.should_term == True):
                _st_label_736 += 1
            else:
                super()._label('_st_label_736', block=True)
                _st_label_736 -= 1

    def get_logger(self, name, filename):
        formatter = logging.Formatter(fmt='%(asctime)s %(levelname)-8s %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
        hld = logging.FileHandler(filename, mode='a')
        hld.setFormatter(formatter)
        self._state.logger = logging.getLogger(name)
        self._state.logger.setLevel(logging.DEBUG)
        self._state.logger.addHandler(hld)
        return self._state.logger

    def getNR(self, t):
        i = 0
        bb = ''
        for c in t:
            i = (i + 1)
            if (c == '('):
                break
        bb = t[i:(len(t) - 1)]
        s_bb = bb.split(',')
        return (int(s_bb[0]), int(s_bb[1]))

    def getN(self, t):
        i = 0
        bb = ''
        for c in t:
            i = (i + 1)
            if (c == '('):
                break
        bb = t[i:(len(t) - 1)]
        return int(bb)

    def logFailureMap(self):
        self._state.logger.info('Client_request : %s', self._state.client_request_t)
        self._state.logger.info('Forwarded Request : %s', self._state.forwarded_request_t)
        self._state.logger.info('Shuttle : %s', self._state.shuttle_t)
        self._state.logger.info('Result Shuttle : %s', self._state.result_shuttle_t)
        self._state.logger.info('Wedge Request : %s', self._state.wedge_request_t)
        self._state.logger.info('New Configuration : %s', self._state.new_config_t)
        self._state.logger.info('Checkpoint : %s', self._state.checkpt_t)
        self._state.logger.info('Complete Checkpoint : %s', self._state.comp_cp_t)
        self._state.logger.info('Get Running State : %s', self._state.get_run_st_t)
        self._state.logger.info('Catch Up : %s', self._state.catch_up_t)

    def parse_failures(self):
        if (not (self._state.failures == None)):
            l_pairs = self._state.failures.split(';')
            for elem in l_pairs:
                if (len(elem.split(',')) == 3):
                    t = ((elem.split(',')[0].strip() + ',') + elem.split(',')[1].strip())
                    f = elem.split(',')[2].strip()
                else:
                    t = elem.split(',')[0].strip()
                    f = elem.split(',')[1].strip()
                stub = t[0:5]
                if (stub == 'clien'):
                    (cn, rn) = self.getNR(t)
                    if (cn in self._state.client_request_t):
                        self._state.client_request_t[cn].append([rn, f])
                    else:
                        self._state.client_request_t[cn] = [[rn, f]]
                elif (stub == 'forwa'):
                    (cn, rn) = self.getNR(t)
                    if (cn in self._state.forwarded_request_t):
                        self._state.forwarded_request_t[cn].append([rn, f])
                    else:
                        self._state.forwarded_request_t[cn] = [[rn, f]]
                elif (stub == 'shutt'):
                    (cn, rn) = self.getNR(t)
                    if (cn in self._state.shuttle_t):
                        self._state.shuttle_t[cn].append([rn, f])
                    else:
                        self._state.shuttle_t[cn] = [[rn, f]]
                elif (stub == 'resul'):
                    (cn, rn) = self.getNR(t)
                    if (cn in self._state.result_shuttle_t):
                        self._state.result_shuttle_t[cn].append([rn, f])
                    else:
                        self._state.result_shuttle_t[cn] = [[rn, f]]
                elif (stub == 'wedge'):
                    cn = self.getN(t)
                    if (cn in self._state.wedge_request_t):
                        self._state.wedge_request_t[cn].append(f)
                    else:
                        self._state.wedge_request_t[cn] = [f]
                elif (stub == 'new_c'):
                    cn = self.getN(t)
                    if (cn in self._state.new_config_t):
                        self._state.new_config_t[cn].append(f)
                    else:
                        self._state.new_config_t[cn] = [f]
                elif (stub == 'check'):
                    cn = self.getN(t)
                    if (cn in self._state.checkpt_t):
                        self._state.checkpt_t[cn].append(f)
                    else:
                        self._state.checkpt_t[cn] = [f]
                elif (stub == 'compl'):
                    cn = self.getN(t)
                    if (cn in self._state.comp_cp_t):
                        self._state.comp_cp_t[cn].append(f)
                    else:
                        self._state.comp_cp_t[cn] = [f]
                elif (stub == 'get_r'):
                    cn = self.getN(t)
                    if (cn in self._state.get_run_st_t):
                        self._state.get_run_st_t[cn].append(f)
                    else:
                        self._state.get_run_st_t[cn] = [f]
                elif (stub == 'catch'):
                    cn = self.getN(t)
                    if (cn in self._state.catch_up_t):
                        self._state.catch_up_t[cn].append(f)
                    else:
                        self._state.catch_up_t[cn] = [f]
        self.logFailureMap()

    def get_slot_number(self):
        s = self._state.current_slot
        self._state.current_slot = (self._state.current_slot + 1)
        return s

    def checkIfRidPresentInHistory(self, requestID):
        if (requestID in self._state.History):
            return True
        return False

    def orderCommand(self, s, o, args):
        os = str(self._id)
        os = ((os + ';') + str(s))
        os = ((os + ';') + o)
        for arg in args:
            os = ((os + ';') + arg)
        for key in self._state.History:
            if (self._state.History[key] == os):
                return 'error'
        return os

    def getCorruptStatement(self, s, o, args):
        os = str(self._id)
        os = ((os + ';') + str(s))
        os = ((os + ';') + o)
        for arg in args:
            os = ((os + ';') + arg)
        return os

    def verifyOrderProof(self, orderProof, requestID):
        orderStatements = orderProof[requestID]
        i = 0
        for key in self._state.replicaKM:
            prev = self._state.replicaKM[key].verify(orderStatements[0])
            break
        prev = prev.decode('utf-8').split(str(key))[1]
        for key in self._state.replicaKM:
            if (i < len(orderStatements)):
                try:
                    t = self._state.replicaKM[key].verify(orderStatements[i]).decode('utf-8').split(str(key))[1]
                    if (not (prev == t)):
                        return False
                except:
                    self.output('Bad or corrupted key.')
                    return False
            else:
                return True
                break
            i = (i + 1)

    def encodeStatement(self, statement):
        enc_s = self._state.privateKey.sign(bytes(statement, 'utf-8'))
        return enc_s

    def validate_checkpoint_proof(self, checkpoint_proof, cp_slot):
        hash_list = []
        hash_list = checkpoint_proof[cp_slot]
        temp = hash_list[0]
        for i in hash_list:
            if (not (i == temp)):
                return False
        return True

    def get_hash(self):
        st = ''
        for (key, val) in self._state.db.items():
            st = ((((st + key) + ':') + val) + ';')
        bst = bytes(st, 'utf-8')
        r_st_hash = self._state.hasher(bst, encoder=nacl.encoding.HexEncoder)
        return r_st_hash

    def truncate_history(self, slot_number):
        self.output('printing history')
        self.output(self._state.History)
        for key in list(self._state.History):
            if (self._state.History[key].split(';')[1] < str(slot_number)):
                del self._state.History[key]
        self.output('printing truncated history')
        self._state.logger.info((str(self._id) + 'Truncated the history'))
        self.output(self._state.History)

    def generate_stub(self, elem):
        st = ''
        for c in elem:
            if (not (c == '()')):
                break
            st = (st + c)
        return st

    def set_f_flags(self, l_f):
        for elem in l_f:
            stub = self.generate_stub(elem)
            if (stub == 'crash'):
                logging.shutdown()
                os._exit((- 1))
            elif (stub == 'truncate_history'):
                n = elem[17:(len(elem) - 1)]
                self._state.th_num = int(n)
                self._state.th_flag = True
            elif (stub == 'sleep'):
                t = elem[6:(len(elem) - 1)]
                time.sleep(int(t))
            elif (stub == 'drop'):
                self._state.dr_flag = True
            elif (stub == 'increment_slot'):
                self._state.is_flag = True
            elif (stub == 'extra_op'):
                self._state.eo_flag = True
            elif (stub == 'invalid_order_sig'):
                self._state.ios_flag = True
            elif (stub == 'invalid_result_sig'):
                self._state.irs_flag = True
            elif (stub == 'drop_checkpt_stmts'):
                self._state.dcs_flag = True

    def set_fail_flags(self, t):
        if (t == 'cp'):
            if (not (len(self._state.checkpt_t) == 0)):
                if (self._state.cp_cnt in self._state.checkpt_t):
                    self.set_f_flags(self._state.checkpt_t[self._state.cp_cnt])
        elif (t == 'nc'):
            if (not (len(self._state.new_config_t) == 0)):
                if ((self._state.curr_config - 1) in self._state.new_config_t):
                    self.set_f_flags(self._state.new_config_t[self._state.nc_cnt])
        elif (t == 'wr'):
            if (not (len(self._state.wedge_request_t) == 0)):
                if (self._state.wr_cnt in self._state.wedge_request_t):
                    self.set_f_flags(self._state.wedge_request_t[self._state.wr_cnt])
        elif (t == 'ccp'):
            if (not (len(self._state.comp_cp_t) == 0)):
                if (self._state.ccp_cnt in self._state.comp_cp_t):
                    self.set_f_flags(self._state.comp_cp_t[self._state.ccp_cnt])
        elif (t == 'grs'):
            if (not (len(self._state.get_run_st_t) == 0)):
                if (self._state.grs_cnt in self._state.get_run_st_t):
                    self.set_f_flags(self._state.get_run_st_t[self._state.grs_cnt])
        elif (t == 'cu'):
            if (not (len(self._state.catch_up_t) == 0)):
                if (self._state.cu_cnt in self._state.catch_up_t):
                    self.set_f_flags(self._state.catch_up_t[self._state.cu_cnt])

    def _Replica_handler_1590(self, cKM, rKM, olympus):
        self._state.replicaKM = rKM
        self._state.clientKM = cKM
    _Replica_handler_1590._labels = None
    _Replica_handler_1590._notlabels = None

    def _Replica_handler_1768(self, cp_slot, checkpoint_proof, p_id):
        self._state.ccp_cnt = (self._state.ccp_cnt + 1)
        self.set_fail_flags(self._state.ccp_cnt)
        if (self._state.state == 'ACTIVE'):
            self.output('received completed checkpoint proof should validate and truncate history')
            self.output(checkpoint_proof)
            self.truncate_history(cp_slot)
            if (not (self._state.isHead == True)):
                self.send(('completed_cp', cp_slot, checkpoint_proof), to=self._state.predecessor)
            self._state.cccslot = cp_slot
            self._state.c_cp_proof = checkpoint_proof
    _Replica_handler_1768._labels = None
    _Replica_handler_1768._notlabels = None

    def _Replica_handler_1835(self, cp_slot, checkpoint_proof, p_id):
        if (self._state.state == 'ACTIVE'):
            if (self._state.current_slot >= cp_slot):
                checkpoint_proof[cp_slot].append(self._state.mod_cp_hash)
                if (not (self._state.isTail == True)):
                    self.output('received checkpoint, appended self hash')
                    self.output(checkpoint_proof)
                    self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                    self.send(('checkpoint', cp_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self.output('In tail added self hash now checking validity')
                    self.output(checkpoint_proof)
                    if self.validate_checkpoint_proof(checkpoint_proof, cp_slot):
                        self.output('Checkpoint proof complete. Sending cp back in the chain')
                        self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                        self.truncate_history(cp_slot)
                        self.send(('completed_cp', cp_slot, checkpoint_proof), to=self._state.predecessor)
                        self._state.cccslot = cp_slot
                        self._state.c_cp_proof = checkpoint_proof
                    else:
                        self.output('Found error in the checkpoint proof, call for reconfiguration')
                        self.output('Actually the result shuttle will anyway cause reconfig request in this case')
            else:
                self.output('Saving the checkpoint until slot reaches required value')
                self._state.chcslot = cp_slot
                self._state.h_cp_proof = checkpoint_proof
    _Replica_handler_1835._labels = None
    _Replica_handler_1835._notlabels = None

    def _Replica_handler_1968(self, k_v, client_id, requestID, p_id):
        cmd = (((('put(' + k_v[0]) + ',') + k_v[1]) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + 'from') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            if (self.checkIfRidPresentInHistory(requestID) == False):
                if self._state.isHead:
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'put', k_v)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + ' is ') + os))
                    enc_os = self.encodeStatement(os)
                    self._state.db[k_v[0]] = k_v[1]
                    orderProof = {}
                    orderProof[requestID] = [enc_os]
                    result_statement = ''
                    result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                    resultProof = {}
                    resultProof[requestID] = [result_statement]
                    OrderShuttle = [orderProof, resultProof]
                    self.send(('put', k_v, client_id, requestID, OrderShuttle), to=self._state.successor)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        checkpoint_proof = {}
                        checkpoint_proof[self._state.current_slot] = [self.get_hash()]
                        self._state.logger.info((str(self._id) + ' Checkpoint reached sending proof to successor'))
                        self.output(checkpoint_proof)
                        self.send(('checkpoint', self._state.current_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self.output('replica says retransmission')
                    self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                    if (requestID in self._state.resultCache):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                        self.send(('put_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                    else:
                        self._state.logger.info((str(self._id) + ' result is not in cache'))
                        self._state.retran_flag = 0
                        self._state.ReTransmittedRequest.append(requestID)
                        self._state.logger.info((str(self._id) + ' Sending the operation to head and waiting for the result shuttle to come back'))
                        self.send(('put', k_v, client_id, requestID), to=self._state.headReplica)
                        super()._label('_st_label_2268', block=False)
                        _st_label_2268 = 0
                        self._timer_start()
                        while (_st_label_2268 == 0):
                            _st_label_2268 += 1
                            if (self._state.retran_flag == 1):
                                self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                                self.send(('put_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                                self._state.retran_flag = 0
                                _st_label_2268 += 1
                            elif self._timer_expired:
                                self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                                self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                                _st_label_2268 += 1
                            else:
                                super()._label('_st_label_2268', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                                _st_label_2268 -= 1
            else:
                self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                if (requestID in self._state.resultCache):
                    self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                    self.send(('put_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                else:
                    self._state.logger.info((str(self._id) + ' result is not in cache'))
                    self._state.retran_flag = 0
                    self._state.ReTransmittedRequest.append(requestID)
                    self._state.logger.info((str(self._id) + ' waiting for the result shuttle to come back'))
                    super()._label('_st_label_2399', block=False)
                    _st_label_2399 = 0
                    self._timer_start()
                    while (_st_label_2399 == 0):
                        _st_label_2399 += 1
                        if (self._state.retran_flag == 1):
                            self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                            self.send(('put_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                            self._state.retran_flag = 0
                            _st_label_2399 += 1
                        elif self._timer_expired:
                            self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                            self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                            _st_label_2399 += 1
                        else:
                            super()._label('_st_label_2399', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                            _st_label_2399 -= 1
        else:
            self.output('Replica is immutable')
            self.send(('immutable', requestID), to=client_id)
    _Replica_handler_1968._labels = None
    _Replica_handler_1968._notlabels = None

    def _Replica_handler_2468(self, k_v, client_id, requestID, OrderShuttle, p_id):
        cmd = (((('put(' + k_v[0]) + ',') + k_v[1]) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            if (not (self._state.isHead == True)):
                if (self.verifyOrderProof(OrderShuttle[0], requestID) == True):
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'put', k_v)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    enc_os = self.encodeStatement(os)
                    self._state.db[k_v[0]] = k_v[1]
                    OrderShuttle[0][requestID].append(enc_os)
                    result_statement = ''
                    result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                    OrderShuttle[1][requestID].append(result_statement)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        self._state.mod_cp_hash = self.get_hash()
                        if ((not (self._state.chcslot == (- 1))) and (self._state.chcslot == self._state.current_slot)):
                            self._state.h_cp_proof[self._state.chcslot].append(self._state.mod_cp_hash)
                            self._state.send_cp = 1
                    if (not (self._state.isTail == True)):
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                        self.send(('put', k_v, client_id, requestID, OrderShuttle), to=self._state.successor)
                        if (self._state.send_cp == 1):
                            self.output(self._state.h_cp_proof)
                            self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                            self.send(('checkpoint', self._state.chcslot, self._state.h_cp_proof), to=self._state.successor)
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                    else:
                        self._state.logger.info(((str(self._id) + ' sending the result shuttle to client: ') + str(client_id)))
                        self.send(('put_result', OrderShuttle[1], requestID), to=client_id)
                        self._state.logger.info(((str(self._id) + ' send the result shuttle back in the chain to: ') + str(self._state.predecessor)))
                        self.send(('result_back', OrderShuttle[1], requestID, client_id), to=self._state.predecessor)
                        if (self._state.send_cp == 1):
                            if self.validate_checkpoint_proof(self._state.h_cp_proof, self._state.chcslot):
                                self.output('Checkpoint proof complete. Sending cp back in the chain')
                                self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                                self.truncate_history(self._state.chcslot)
                                self.send(('completed_cp', self._state.chcslot, self._state.h_cp_proof), to=self._state.predecessor)
                                self._state.cccslot = self._state.chcslot
                                self._state.c_cp_proof = self._state.h_cp_proof
                            else:
                                self.output('Found error in the checkpoint proof, call for reconfiguration')
                                self.output('Actually the result shuttle will anyway cause reconfig request in this case')
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                else:
                    self._state.logger.info((str(self._id) + ' There orderProof is not correct. Becoming IMMUTABLE and sending reconfiguration request to olympus'))
                    self.output('Dropping invalid request')
                    self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_2468._labels = None
    _Replica_handler_2468._notlabels = None

    def _Replica_handler_2916(self, key, client_id, requestID, p_id):
        cmd = (('get(' + key) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            if (self.checkIfRidPresentInHistory(requestID) == False):
                if self._state.isHead:
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'get', [key])
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    enc_os = self.encodeStatement(os)
                    orderProof = {}
                    orderProof[requestID] = [enc_os]
                    result_statement = ''
                    if (key in self._state.db):
                        result_statement = self.encodeStatement(((str(self._id) + ';') + self._state.db[key]))
                    else:
                        result_statement = self.encodeStatement((str(self._id) + ';'))
                    resultProof = {}
                    resultProof[requestID] = [result_statement]
                    OrderShuttle = [orderProof, resultProof]
                    self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                    self.send(('get', key, client_id, requestID, OrderShuttle), to=self._state.successor)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        checkpoint_proof = {}
                        checkpoint_proof[self._state.current_slot] = [self.get_hash()]
                        self._state.logger.info((str(self._id) + ' Checkpoint reached sending proof to successor'))
                        self.output(checkpoint_proof)
                        self.send(('checkpoint', self._state.current_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                    if (requestID in self._state.resultCache):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                        self.send(('get_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                    else:
                        self._state.logger.info((str(self._id) + ' result is not in cache'))
                        self._state.retran_flag = 0
                        self._state.ReTransmittedRequest.append(requestID)
                        self._state.logger.info((str(self._id) + ' Sending the operation to head and waiting for the result shuttle to come back'))
                        self.send(('get', key, client_id, requestID), to=self._state.headReplica)
                        super()._label('_st_label_3230', block=False)
                        _st_label_3230 = 0
                        self._timer_start()
                        while (_st_label_3230 == 0):
                            _st_label_3230 += 1
                            if (self._state.retran_flag == 1):
                                self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                                self.send(('get_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                                self._state.retran_flag = 0
                                _st_label_3230 += 1
                            elif self._timer_expired:
                                self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                                self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                                _st_label_3230 += 1
                            else:
                                super()._label('_st_label_3230', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                                _st_label_3230 -= 1
            else:
                self._state.logger.info((str(self._id) + ' result is not in cache'))
                self._state.retran_flag = 0
                self._state.ReTransmittedRequest.append(requestID)
                self._state.logger.info((str(self._id) + ' waiting for the result shuttle to come back'))
                super()._label('_st_label_3320', block=False)
                _st_label_3320 = 0
                self._timer_start()
                while (_st_label_3320 == 0):
                    _st_label_3320 += 1
                    if (self._state.retran_flag == 1):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                        self.send(('get_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                        self._state.retran_flag = 0
                        _st_label_3320 += 1
                    elif self._timer_expired:
                        self._state.logger.info((str(self._id) + ' timed out. Becomes immutable and sends the reconfiguration request to olympus'))
                        self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                        _st_label_3320 += 1
                    else:
                        super()._label('_st_label_3320', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                        _st_label_3320 -= 1
        else:
            self.output('Replica is immutable')
            self.send(('immutable', requestID), to=client_id)
    _Replica_handler_2916._labels = None
    _Replica_handler_2916._notlabels = None

    def _Replica_handler_3389(self, key, client_id, requestID, OrderShuttle, p_id):
        cmd = (('get(' + key) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            if (not (self._state.isHead == True)):
                if (self.verifyOrderProof(OrderShuttle[0], requestID) == True):
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'get', [key])
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    enc_os = self.encodeStatement(os)
                    OrderShuttle[0][requestID].append(enc_os)
                    result_statement = ''
                    if (key in self._state.db):
                        result_statement = self.encodeStatement(((str(self._id) + ';') + self._state.db[key]))
                    else:
                        result_statement = self.encodeStatement((str(self._id) + ';'))
                    OrderShuttle[1][requestID].append(result_statement)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        self._state.mod_cp_hash = self.get_hash()
                        if ((not (self._state.chcslot == (- 1))) and (self._state.chcslot == self._state.current_slot)):
                            self._state.h_cp_proof[self._state.chcslot].append(self._state.mod_cp_hash)
                            self._state.send_cp = 1
                    if (not (self._state.isTail == True)):
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                        self.send(('get', key, client_id, requestID, OrderShuttle), to=self._state.successor)
                        if (self._state.send_cp == 1):
                            self.output(self._state.h_cp_proof)
                            self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                            self.send(('checkpoint', self._state.chcslot, self._state.h_cp_proof), to=self._state.successor)
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                    else:
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(client_id)))
                        self.send(('get_result', OrderShuttle[1], requestID), to=client_id)
                        self._state.logger.info(((str(self._id) + ' sending result shuttle forward to ') + str(self._state.predecessor)))
                        if (self._state.send_cp == 1):
                            if self.validate_checkpoint_proof(self._state.h_cp_proof, self._state.chcslot):
                                self.output('Checkpoint proof complete. Sending cp back in the chain')
                                self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                                self.truncate_history(self._state.chcslot)
                                self.send(('completed_cp', self._state.chcslot, self._state.h_cp_proof), to=self._state.predecessor)
                                self._state.cccslot = self._state.chcslot
                                self._state.c_cp_proof = self._state.h_cp_proof
                            else:
                                self.output('Found error in the checkpoint proof, call for reconfiguration')
                                self.output('Actually the result shuttle will anyway cause reconfig request in this case')
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                else:
                    self._state.logger.info((str(self._id) + ' There orderProof is not correct. Becoming IMMUTABLE and sending reconfiguration request to olympus'))
                    self.output('Dropping invalid request')
                    self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_3389._labels = None
    _Replica_handler_3389._notlabels = None

    def _Replica_handler_3826(self, args, client_id, requestID, p_id):
        cmd = (('slice(' + str(args)) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            if (self.checkIfRidPresentInHistory(requestID) == False):
                if self._state.isHead:
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'slice', args)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    orderProof = {}
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    enc_os = self.encodeStatement(os)
                    orderProof[requestID] = [enc_os]
                    result_statement = ''
                    (start, end) = args[1].split(':')
                    if (args[0] in self._state.db):
                        val = self._state.db[args[0]]
                        if ((int(start) >= 0) and (int(end) <= len(val))):
                            val = val[int(start):int(end)]
                            self._state.db[args[0]] = val
                            result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        else:
                            result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    else:
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    resultProof = {}
                    resultProof[requestID] = [result_statement]
                    OrderShuttle = [orderProof, resultProof]
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'drop_result_statement')):
                        self._state.logger.info((str(self._id) + ' Injecting the drop_result_statement failure'))
                        self.output('injecting drop_result_statement Failure')
                        OrderShuttle[1][requestID].pop(0)
                        self._state.curr_fail_op = ''
                    self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                    self.send(('slice', args, client_id, requestID, OrderShuttle), to=self._state.successor)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        checkpoint_proof = {}
                        checkpoint_proof[self._state.current_slot] = [self.get_hash()]
                        self._state.logger.info((str(self._id) + ' Checkpoint reached sending proof to successor'))
                        self.output(checkpoint_proof)
                        self.send(('checkpoint', self._state.current_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                    if (requestID in self._state.resultCache):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                        self.send(('slice_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                    else:
                        self._state.logger.info((str(self._id) + ' result is not in cache'))
                        self._state.retran_flag = 0
                        self._state.ReTransmittedRequest.append(requestID)
                        self._state.logger.info((str(self._id) + ' Sending the operation to head and waiting for the result shuttle to come back'))
                        self.send(('slice', args, client_id, requestID), to=self._state.headReplica)
                        super()._label('_st_label_4242', block=False)
                        _st_label_4242 = 0
                        self._timer_start()
                        while (_st_label_4242 == 0):
                            _st_label_4242 += 1
                            if (self._state.retran_flag == 1):
                                self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                                self.send(('slice_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                                self._state.retran_flag = 0
                                _st_label_4242 += 1
                            elif self._timer_expired:
                                self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                                self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                                _st_label_4242 += 1
                            else:
                                super()._label('_st_label_4242', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                                _st_label_4242 -= 1
            else:
                self._state.logger.info((str(self._id) + ' result is not in cache'))
                self._state.retran_flag = 0
                self._state.ReTransmittedRequest.append(requestID)
                self._state.logger.info((str(self._id) + ' waiting for the result shuttle to come back'))
                super()._label('_st_label_4332', block=False)
                _st_label_4332 = 0
                self._timer_start()
                while (_st_label_4332 == 0):
                    _st_label_4332 += 1
                    if (self._state.retran_flag == 1):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                        self.send(('slice_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                        self._state.retran_flag = 0
                        _st_label_4332 += 1
                    elif self._timer_expired:
                        self._state.logger.info((str(self._id) + ' timed out. Becomes immutable and sends the reconfiguration request to olympus'))
                        self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                        _st_label_4332 += 1
                    else:
                        super()._label('_st_label_4332', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                        _st_label_4332 -= 1
        else:
            self.output('Replica is immutable')
            self.send(('immutable', requestID), to=client_id)
    _Replica_handler_3826._labels = None
    _Replica_handler_3826._notlabels = None

    def _Replica_handler_4401(self, args, client_id, requestID, OrderShuttle, p_id):
        cmd = (('slice(' + str(args)) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            if (not (self._state.isHead == True)):
                if (self.verifyOrderProof(OrderShuttle[0], requestID) == True):
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'slice', args)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    enc_os = self.encodeStatement(os)
                    OrderShuttle[0][requestID].append(enc_os)
                    result_statement = ''
                    (start, end) = args[1].split(':')
                    if (args[0] in self._state.db):
                        val = self._state.db[args[0]]
                        if ((int(start) >= 0) and (int(end) <= len(val))):
                            val = val[int(start):int(end)]
                            self._state.db[args[0]] = val
                            result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        else:
                            result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    else:
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    OrderShuttle[1][requestID].append(result_statement)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        self._state.mod_cp_hash = self.get_hash()
                        if ((not (self._state.chcslot == (- 1))) and (self._state.chcslot == self._state.current_slot)):
                            self._state.h_cp_proof[self._state.chcslot].append(self._state.mod_cp_hash)
                            self._state.send_cp = 1
                    if (not (self._state.isTail == True)):
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                        self.send(('slice', args, client_id, requestID, OrderShuttle), to=self._state.successor)
                        if (self._state.send_cp == 1):
                            self.output(self._state.h_cp_proof)
                            self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                            self.send(('checkpoint', self._state.chcslot, self._state.h_cp_proof), to=self._state.successor)
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                    else:
                        self._state.logger.info(((str(self._id) + ' sending result shuttle to ') + str(client_id)))
                        self.send(('slice_result', OrderShuttle[1], requestID), to=client_id)
                        self._state.logger.info(((str(self._id) + ' sending result shuttle back to ') + str(self._state.predecessor)))
                        self.send(('result_back', OrderShuttle[1], requestID, client_id), to=self._state.predecessor)
                        if (self._state.send_cp == 1):
                            if self.validate_checkpoint_proof(self._state.h_cp_proof, self._state.chcslot):
                                self.output('Checkpoint proof complete. Sending cp back in the chain')
                                self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                                self.truncate_history(self._state.chcslot)
                                self.send(('completed_cp', self._state.chcslot, self._state.h_cp_proof), to=self._state.predecessor)
                                self._state.cccslot = self._state.chcslot
                                self._state.c_cp_proof = self._state.h_cp_proof
                            else:
                                self.output('Found error in the checkpoint proof, call for reconfiguration')
                                self.output('Actually the result shuttle will anyway cause reconfig request in this case')
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                else:
                    self._state.logger.info((str(self._id) + ' There orderProof is not correct. Becoming IMMUTABLE and sending reconfiguration request to olympus'))
                    self.output('Dropping invalid request')
                    self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_4401._labels = None
    _Replica_handler_4401._notlabels = None

    def _Replica_handler_4917(self, args, client_id, requestID, p_id):
        cmd = (('append(' + str(args)) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            if (self.checkIfRidPresentInHistory(requestID) == False):
                if self._state.isHead:
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'append', args)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    orderProof = {}
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    enc_os = self.encodeStatement(os)
                    orderProof[requestID] = [enc_os]
                    result_statement = ''
                    if (args[0] in self._state.db):
                        val = self._state.db[args[0]]
                        val = ((val + ' ') + args[1])
                        self._state.db[args[0]] = val
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                    else:
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    resultProof = {}
                    resultProof[requestID] = [result_statement]
                    OrderShuttle = [orderProof, resultProof]
                    self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                    self.send(('append', args, client_id, requestID, OrderShuttle), to=self._state.successor)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        checkpoint_proof = {}
                        checkpoint_proof[self._state.current_slot] = [self.get_hash()]
                        self._state.logger.info((str(self._id) + ' Checkpoint reached sending proof to successor'))
                        self.output(checkpoint_proof)
                        self.send(('checkpoint', self._state.current_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                    if (requestID in self._state.resultCache):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                        self.send(('append_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                    else:
                        self._state.logger.info((str(self._id) + ' result is not in cache'))
                        self._state.retran_flag = 0
                        self._state.ReTransmittedRequest.append(requestID)
                        self._state.logger.info((str(self._id) + ' Sending the operation to head and waiting for the result shuttle to come back'))
                        self.send(('append', args, client_id, requestID), to=self._state.headReplica)
                        super()._label('_st_label_5260', block=False)
                        _st_label_5260 = 0
                        self._timer_start()
                        while (_st_label_5260 == 0):
                            _st_label_5260 += 1
                            if (self._state.retran_flag == 1):
                                self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                                self.send(('append_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                                self._state.retran_flag = 0
                                _st_label_5260 += 1
                            elif self._timer_expired:
                                self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                                self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                                _st_label_5260 += 1
                            else:
                                super()._label('_st_label_5260', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                                _st_label_5260 -= 1
            else:
                self._state.logger.info((str(self._id) + ' result is not in cache'))
                self._state.retran_flag = 0
                self._state.ReTransmittedRequest.append(requestID)
                self._state.logger.info((str(self._id) + ' waiting for the result shuttle to come back'))
                super()._label('_st_label_5350', block=False)
                _st_label_5350 = 0
                self._timer_start()
                while (_st_label_5350 == 0):
                    _st_label_5350 += 1
                    if (self._state.retran_flag == 1):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                        self.send(('append_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                        self._state.retran_flag = 0
                        _st_label_5350 += 1
                    elif self._timer_expired:
                        self._state.logger.info((str(self._id) + ' timed out. Becomes immutable and sends the reconfiguration request to olympus'))
                        self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                        _st_label_5350 += 1
                    else:
                        super()._label('_st_label_5350', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                        _st_label_5350 -= 1
        else:
            self.output('Replica is immutable')
            self.send(('immutable', requestID), to=client_id)
    _Replica_handler_4917._labels = None
    _Replica_handler_4917._notlabels = None

    def _Replica_handler_5419(self, args, client_id, requestID, OrderShuttle, p_id):
        cmd = (('append(' + str(args)) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            if (not (self._state.isHead == True)):
                if (self.verifyOrderProof(OrderShuttle[0], requestID) == True):
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'append', args)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    enc_os = self.encodeStatement(os)
                    OrderShuttle[0][requestID].append(enc_os)
                    result_statement = ''
                    if (args[0] in self._state.db):
                        val = self._state.db[args[0]]
                        val = ((val + ' ') + args[1])
                        self._state.db[args[0]] = val
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                    else:
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    OrderShuttle[1][requestID].append(result_statement)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        self._state.mod_cp_hash = self.get_hash()
                        if ((not (self._state.chcslot == (- 1))) and (self._state.chcslot == self._state.current_slot)):
                            self._state.h_cp_proof[self._state.chcslot].append(self._state.mod_cp_hash)
                            self._state.send_cp = 1
                    if (not (self._state.isTail == True)):
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                        self.send(('append', args, client_id, requestID, OrderShuttle), to=self._state.successor)
                        if (self._state.send_cp == 1):
                            self.output(self._state.h_cp_proof)
                            self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                            self.send(('checkpoint', self._state.chcslot, self._state.h_cp_proof), to=self._state.successor)
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                    else:
                        self._state.logger.info(((str(self._id) + ' sending result shuttle to ') + str(client_id)))
                        self.send(('append_result', OrderShuttle[1], requestID), to=client_id)
                        self._state.logger.info(((str(self._id) + ' sending result shuttle back to ') + str(self._state.predecessor)))
                        self.send(('result_back', OrderShuttle[1], requestID, client_id), to=self._state.predecessor)
                        if (self._state.send_cp == 1):
                            if self.validate_checkpoint_proof(self._state.h_cp_proof, self._state.chcslot):
                                self.output('Checkpoint proof complete. Sending cp back in the chain')
                                self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                                self.truncate_history(self._state.chcslot)
                                self.send(('completed_cp', self._state.chcslot, self._state.h_cp_proof), to=self._state.predecessor)
                                self._state.cccslot = self._state.chcslot
                                self._state.c_cp_proof = self._state.h_cp_proof
                            else:
                                self.output('Found error in the checkpoint proof, call for reconfiguration')
                                self.output('Actually the result shuttle will anyway cause reconfig request in this case')
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                else:
                    self._state.logger.info((str(self._id) + ' There orderProof is not correct. Becoming IMMUTABLE and sending reconfiguration request to olympus'))
                    self.output('Dropping invalid request')
                    self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_5419._labels = None
    _Replica_handler_5419._notlabels = None

    def _Replica_handler_5897(self, client_id):
        self.send(('dict_reply', self._state.db), to=client_id)
    _Replica_handler_5897._labels = None
    _Replica_handler_5897._notlabels = None

    def _Replica_handler_5914(self, cp_sn, checkpoint_proof, p_id):
        self._state.chcslot = cp_sn
        self._state.h_cp_proof = checkpoint_proof
        self._state.cp_cnt = (self._state.cp_cnt + 1)
        self.set_fail_flags('cp')
    _Replica_handler_5914._labels = None
    _Replica_handler_5914._notlabels = None

    def _Replica_handler_5951(self, result_shuttle, requestID, clientID, p_id):
        cond = True
        resultStatements = result_shuttle[requestID]
        i = 0
        for key in self._state.replicaKM:
            try:
                self._state.replicaKM[key].verify(resultStatements[i])
                i = (i + 1)
            except:
                cond = False
                break
        if (cond == True):
            if (requestID in self._state.ReTransmittedRequest):
                self.output('Sending back the response of retransmitted request to : CLIENT')
                self._state.resultCache[requestID] = result_shuttle[requestID]
                if (self._state.isHead == False):
                    self.send(('result_back', result_shuttle, requestID), to=self._state.predecessor)
                self._state.retran_flag = 1
            else:
                self._state.resultCache[requestID] = result_shuttle[requestID]
                if (self._state.isHead == False):
                    self.send(('result_back', result_shuttle, requestID), to=self._state.predecessor)
        else:
            self.output('Needs reconfiguration as the result shuttle is inconsistent. The replica will become immutable.')
            self._state.logger.info((str(self._id) + ' Result shuttle not consistent. Sending reconfig request to oly'))
            self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_5951._labels = None
    _Replica_handler_5951._notlabels = None

    def _Replica_handler_6090(self, p, s, head, olympus):
        self._state.successor = s
        self._state.predecessor = p
        self._state.headReplica = head
        self._state.flag = 1
    _Replica_handler_6090._labels = None
    _Replica_handler_6090._notlabels = None

    def _Replica_handler_6126(self, olym):
        self._state.state = 'IMMUTABLE'
        self._state.wr_cnt = (self._state.wr_cnt + 1)
        self.set_fail_flags('wr')
        self.send(('wedged_reply', self._id, self._state.History, self._state.c_cp_proof), to=olym)
    _Replica_handler_6126._labels = None
    _Replica_handler_6126._notlabels = None

    def _Replica_handler_6165(self, olymp):
        self.send(('running_state', self._state.db), to=olymp)
        self._state.should_term = True
    _Replica_handler_6165._labels = None
    _Replica_handler_6165._notlabels = None

    def _Replica_handler_6187(self, catch_up_hist, olym):
        self._state.logger.info((str(self._id) + 'Catch_up message received'))
        self._state.logger.info((str(self._id) + ' Catch up history is: %s'), catch_up_hist)
        if (not (len(catch_up_hist) == 0)):
            for rid in catch_up_hist:
                slot = self.get_slot_number()
                cmd = catch_up_hist[rid]
                if (cmd.split(';')[2] == 'put'):
                    key = cmd.split(';')[3]
                    val = cmd.split(';')[4]
                    self._state.db[key] = val
                elif (cmd.split(';')[2] == 'slice'):
                    key = cmd.split(';')[3]
                    value = cmd.split(';')[4]
                    (start, end) = value.split(':')
                    v = self._state.db[key]
                    if ((int(start) >= 0) and (int(end) <= len(v))):
                        v = v[int(start):int(end)]
                        self._state.db[key] = v
                elif (cmd.split(';')[2] == 'append'):
                    key = cmd.split(';')[3]
                    value = cmd.split(';')[4]
                    if (key in self._state.db):
                        v = self._state.db[key]
                        v = ((v + ' ') + value)
                        self._state.db[key] = val
        self._state.logger.info((str(self._id) + ' Catching up successful. sending back caught up message. New state is : %s'), self._state.db)
        new_hash = self.get_hash()
        self.send(('caught_up', new_hash, self._state.db), to=olym)
        self._state.logger.info((str(self._id) + ' Caught_up hash sent'))
        self._state.should_term = True
    _Replica_handler_6187._labels = None
    _Replica_handler_6187._notlabels = None

    def _Replica_handler_6441(self, client):
        if (self._state.isHead == True):
            self._state.db['jedi'] = 'skywalker'
            self._state.History[(str(self._id) + str(self._state.current_slot))] = (((str(self._id) + ';') + str(self._state.current_slot)) + ';put;jedi;skywalker')
            self._state.db['sith'] = 'jarjarbinks'
            self._state.current_slot = (self._state.current_slot + 1)
            self._state.History[(str(self._id) + str(self._state.current_slot))] = (((str(self._id) + ';') + str(self._state.current_slot)) + ';put;sith;jarjarbinks')
        self.send(('immutable', (str(client) + 'rfg')), to=client)
        self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_6441._labels = None
    _Replica_handler_6441._notlabels = None
