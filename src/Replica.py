# -*- generated by 1.0.9 -*-
import da
PatternExpr_1316 = da.pat.TuplePattern([da.pat.ConstantPattern('public_key_maps'), da.pat.FreePattern('cKM'), da.pat.FreePattern('rKM')])
PatternExpr_1325 = da.pat.FreePattern('olympus')
PatternExpr_1494 = da.pat.TuplePattern([da.pat.ConstantPattern('completed_cp'), da.pat.FreePattern('cp_slot'), da.pat.FreePattern('checkpoint_proof')])
PatternExpr_1503 = da.pat.FreePattern('p_id')
PatternExpr_1546 = da.pat.TuplePattern([da.pat.ConstantPattern('checkpoint'), da.pat.FreePattern('cp_slot'), da.pat.FreePattern('checkpoint_proof')])
PatternExpr_1555 = da.pat.FreePattern('p_id')
PatternExpr_1679 = da.pat.TuplePattern([da.pat.ConstantPattern('put'), da.pat.FreePattern('k_v'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID')])
PatternExpr_1690 = da.pat.FreePattern('p_id')
PatternExpr_2299 = da.pat.TuplePattern([da.pat.ConstantPattern('put'), da.pat.FreePattern('k_v'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID'), da.pat.FreePattern('OrderShuttle')])
PatternExpr_2312 = da.pat.FreePattern('p_id')
PatternExpr_2870 = da.pat.TuplePattern([da.pat.ConstantPattern('get'), da.pat.FreePattern('key'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID')])
PatternExpr_2881 = da.pat.FreePattern('p_id')
PatternExpr_3463 = da.pat.TuplePattern([da.pat.ConstantPattern('get'), da.pat.FreePattern('key'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID'), da.pat.FreePattern('OrderShuttle')])
PatternExpr_3476 = da.pat.FreePattern('p_id')
PatternExpr_4044 = da.pat.TuplePattern([da.pat.ConstantPattern('slice'), da.pat.FreePattern('args'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID')])
PatternExpr_4055 = da.pat.FreePattern('p_id')
PatternExpr_4704 = da.pat.TuplePattern([da.pat.ConstantPattern('slice'), da.pat.FreePattern('args'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID'), da.pat.FreePattern('OrderShuttle')])
PatternExpr_4717 = da.pat.FreePattern('p_id')
PatternExpr_5352 = da.pat.TuplePattern([da.pat.ConstantPattern('append'), da.pat.FreePattern('args'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID')])
PatternExpr_5363 = da.pat.FreePattern('p_id')
PatternExpr_5974 = da.pat.TuplePattern([da.pat.ConstantPattern('append'), da.pat.FreePattern('args'), da.pat.FreePattern('client_id'), da.pat.FreePattern('requestID'), da.pat.FreePattern('OrderShuttle')])
PatternExpr_5987 = da.pat.FreePattern('p_id')
PatternExpr_6584 = da.pat.ConstantPattern('get_dict')
PatternExpr_6588 = da.pat.FreePattern('client_id')
PatternExpr_6601 = da.pat.TuplePattern([da.pat.ConstantPattern('checkpoint'), da.pat.FreePattern('cp_sn'), da.pat.FreePattern('checkpoint_proof')])
PatternExpr_6610 = da.pat.FreePattern('p_id')
PatternExpr_6625 = da.pat.TuplePattern([da.pat.ConstantPattern('result_back'), da.pat.FreePattern('result_shuttle'), da.pat.FreePattern('requestID'), da.pat.FreePattern('clientID')])
PatternExpr_6636 = da.pat.FreePattern('p_id')
PatternExpr_6764 = da.pat.TuplePattern([da.pat.ConstantPattern('val_chain_info'), da.pat.FreePattern('p'), da.pat.FreePattern('s'), da.pat.FreePattern('head')])
PatternExpr_6774 = da.pat.FreePattern('olympus')
PatternExpr_6800 = da.pat.ConstantPattern('wedge_request')
PatternExpr_6804 = da.pat.FreePattern('olym')
PatternExpr_6826 = da.pat.ConstantPattern('reconfig')
PatternExpr_6830 = da.pat.FreePattern('client')
_config_object = {}
import time
import collections
import sys
import logging
import nacl.hash

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_1316, sources=[PatternExpr_1325], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1315]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_1494, sources=[PatternExpr_1503], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1493]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_1546, sources=[PatternExpr_1555], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1545]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_1679, sources=[PatternExpr_1690], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1678]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_2299, sources=[PatternExpr_2312], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2298]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_2870, sources=[PatternExpr_2881], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2869]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_3463, sources=[PatternExpr_3476], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3462]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_4044, sources=[PatternExpr_4055], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4043]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_4704, sources=[PatternExpr_4717], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4703]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_9', PatternExpr_5352, sources=[PatternExpr_5363], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5351]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_10', PatternExpr_5974, sources=[PatternExpr_5987], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5973]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_11', PatternExpr_6584, sources=[PatternExpr_6588], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6583]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_12', PatternExpr_6601, sources=[PatternExpr_6610], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6600]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_13', PatternExpr_6625, sources=[PatternExpr_6636], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6624]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_14', PatternExpr_6764, sources=[PatternExpr_6774], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6763]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_15', PatternExpr_6800, sources=[PatternExpr_6804], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6799]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_16', PatternExpr_6826, sources=[PatternExpr_6830], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6825])])

    def setup(self, conf, head, tail, pri_key, cni, failures, cc, olympus, **rest_6907):
        super().setup(conf=conf, head=head, tail=tail, pri_key=pri_key, cni=cni, failures=failures, cc=cc, olympus=olympus, **rest_6907)
        self._state.conf = conf
        self._state.head = head
        self._state.tail = tail
        self._state.pri_key = pri_key
        self._state.cni = cni
        self._state.failures = failures
        self._state.cc = cc
        self._state.olympus = olympus
        self._state.db = {}
        self._state.state = 'ACTIVE'
        self._state.isHead = self._state.head
        self._state.isTail = self._state.tail
        self._state.headReplica = None
        self._state.successor = self._id
        self._state.predecessor = self._id
        self._state.History = {}
        self._state.current_slot = 0
        self._state.resultCache = {}
        self._state.retran_flag = 0
        self._state.ReTransmittedRequest = []
        self._state.privateKey = self._state.pri_key
        self._state.replicaKM = {}
        self._state.clientKM = {}
        self._state.flag = 0
        self._state.client_num_id = self._state.cni
        self._state.failures = self._state.failures
        self._state.failure_map = collections.defaultdict(dict)
        self._state.fail_flag = False
        self._state.curr_fail_op = ''
        self._state.logger = None
        self._state.cp_interval = (- 1)
        self._state.cccslot = (- 1)
        self._state.chcslot = (- 1)
        self._state.h_cp_proof = {}
        self._state.c_cp_proof = {}
        self._state.hasher = nacl.hash.sha256
        self._state.mod_cp_hash = ''
        self._state.send_cp = 0
        self._state.curr_config = self._state.cc

    def run(self):
        logger_file_name = ((self._state.conf['test_case_name'] + str(self._id).split(':')[1]) + '_r.txt')
        self._state.cp_interval = int(self._state.conf['checkpt_interval'])
        self._state.logger = self.get_logger('replica', logger_file_name)
        self._state.logger.info((str(self._id) + ' Getting chain info from olympus'))
        self.send('get_chain_info', to=self._state.olympus)
        super()._label('_st_label_485', block=False)
        _st_label_485 = 0
        while (_st_label_485 == 0):
            _st_label_485 += 1
            if (self._state.flag == 1):
                _st_label_485 += 1
            else:
                super()._label('_st_label_485', block=True)
                _st_label_485 -= 1
        self._state.flag = 0
        self._state.logger.info((str(self._id) + ' getting public key maps from olympus'))
        self.send('get_public_key_maps', to=self._state.olympus)
        self._state.logger.info((str(self._id) + ' Parsing failures'))
        self.parse_failures()
        self._state.logger.info(((str(self._id) + ' ') + str(self._state.failures)))
        self.output(self._id, self._state.failures)
        super()._label('_st_label_542', block=False)
        _st_label_542 = 0
        while (_st_label_542 == 0):
            _st_label_542 += 1
            if False:
                _st_label_542 += 1
            else:
                super()._label('_st_label_542', block=True)
                _st_label_542 -= 1

    def get_logger(self, name, filename):
        formatter = logging.Formatter(fmt='%(asctime)s %(levelname)-8s %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
        hld = logging.FileHandler(filename, mode='a')
        hld.setFormatter(formatter)
        self._state.logger = logging.getLogger(name)
        self._state.logger.setLevel(logging.DEBUG)
        self._state.logger.addHandler(hld)
        return self._state.logger

    def parseFString(self, t):
        tg = ''
        cnum = ''
        rnum = ''
        fl = 'trig'
        for c in t:
            if (fl == 'trig'):
                if (not (c == '(')):
                    tg = (tg + c)
                else:
                    fl = 'cnum'
                    continue
            elif (fl == 'cnum'):
                if (not (c == ',')):
                    cnum = (cnum + c)
                else:
                    fl = 'rnum'
                    continue
            elif (fl == 'rnum'):
                if (not (c == ')')):
                    rnum = (rnum + c)
                else:
                    break
        return (tg.strip(), int(cnum), int(rnum))

    def getFailure(self, fl):
        f = ''
        for c in fl:
            if (not (c == '(')):
                f = (f + c)
            else:
                break
        return f.strip()

    def parse_failures(self):
        if (not (self._state.failures == None)):
            for elem in self._state.failures:
                elem = elem.split(',')
                t = ((elem[0] + ',') + elem[1]).strip()
                f = elem[2].strip()
                (t_name, t_cli, t_r_num) = self.parseFString(t)
                t_f = self.getFailure(f)
                client_id = self._state.client_num_id[t_cli]
                self._state.failure_map[str(client_id)][t_name] = [t_r_num, t_f]

    def check_if_failure(self, client_id, f_type):
        if ((not (self._state.failures == None)) and (client_id in self._state.failure_map) and (f_type in self._state.failure_map[client_id])):
            if (f_type == 'client_request'):
                req_num_max = self._state.failure_map[client_id][f_type][0]
                if ((req_num_max - 1) == 0):
                    req_num_max = (req_num_max - 1)
                    self._state.failure_map[client_id][f_type][0] = req_num_max
                    self._state.curr_fail_op = self._state.failure_map[client_id][f_type][1]
                    return True
                else:
                    req_num_max = (req_num_max - 1)
                    self._state.failure_map[client_id][f_type][0] = req_num_max
                return False
            elif ((f_type == 'forwarded_request') and (client_id in self._state.failure_map) and (f_type in self._state.failure_map[client_id])):
                req_num_max = self._state.failure_map[client_id][f_type][0]
                if ((req_num_max - 1) == 0):
                    req_num_max = (req_num_max - 1)
                    self._state.failure_map[client_id][f_type][0] = req_num_max
                    self._state.curr_fail_op = self._state.failure_map[client_id][f_type][1]
                    return True
                else:
                    req_num_max = (req_num_max - 1)
                    self._state.failure_map[client_id][f_type][0] = req_num_max
                return False
            elif ((f_type == 'result_shuttle') and (client_id in self._state.failure_map) and (f_type in self._state.failure_map[client_id])):
                req_num_max = self._state.failure_map[client_id][f_type][0]
                if ((req_num_max - 1) == 0):
                    req_num_max = (req_num_max - 1)
                    self._state.failure_map[client_id][f_type][0] = req_num_max
                    self._state.curr_fail_op = self._state.failure_map[client_id][f_type][1]
                    return True
                else:
                    req_num_max = (req_num_max - 1)
                    self._state.failure_map[client_id][f_type][0] = req_num_max
                return False
            elif ((f_type == 'shuttle') and (client_id in self._state.failure_map) and (f_type in self._state.failure_map[client_id])):
                req_num_max = self._state.failure_map[client_id][f_type][0]
                if ((req_num_max - 1) == 0):
                    req_num_max = (req_num_max - 1)
                    self._state.failure_map[client_id][f_type][0] = req_num_max
                    self._state.curr_fail_op = self._state.failure_map[client_id][f_type][1]
                    return True
                else:
                    req_num_max = (req_num_max - 1)
                    self._state.failure_map[client_id][f_type][0] = req_num_max
                return False
        else:
            return False

    def get_slot_number(self):
        s = self._state.current_slot
        self._state.current_slot = (self._state.current_slot + 1)
        return s

    def checkIfRidPresentInHistory(self, requestID):
        if (requestID in self._state.History):
            return True
        return False

    def orderCommand(self, s, o, args):
        os = str(self._id)
        os = ((os + ';') + str(s))
        os = ((os + ';') + o)
        for arg in args:
            os = ((os + ';') + arg)
        for key in self._state.History:
            if (self._state.History[key] == os):
                return 'error'
        return os

    def getCorruptStatement(self, s, o, args):
        os = str(self._id)
        os = ((os + ';') + str(s))
        os = ((os + ';') + o)
        for arg in args:
            os = ((os + ';') + arg)
        return os

    def verifyOrderProof(self, orderProof, requestID):
        orderStatements = orderProof[requestID]
        i = 0
        for key in self._state.replicaKM:
            prev = self._state.replicaKM[key].verify(orderStatements[0])
            break
        prev = prev.decode('utf-8').split(str(key))[1]
        for key in self._state.replicaKM:
            if (i < len(orderStatements)):
                try:
                    t = self._state.replicaKM[key].verify(orderStatements[i]).decode('utf-8').split(str(key))[1]
                    if (not (prev == t)):
                        return False
                except:
                    self.output('Bad or corrupted key.')
                    return False
            else:
                return True
                break
            i = (i + 1)

    def encodeStatement(self, statement):
        enc_s = self._state.privateKey.sign(bytes(statement, 'utf-8'))
        return enc_s

    def validate_checkpoint_proof(self, checkpoint_proof, cp_slot):
        hash_list = []
        hash_list = checkpoint_proof[cp_slot]
        temp = hash_list[0]
        for i in hash_list:
            if (not (i == temp)):
                return False
        return True

    def get_hash(self):
        st = ''
        for (key, val) in self._state.db.items():
            st = ((((st + key) + ':') + val) + ';')
        bst = bytes(st, 'utf-8')
        r_st_hash = self._state.hasher(bst, encoder=nacl.encoding.HexEncoder)
        return r_st_hash

    def truncate_history(self, slot_number):
        self.output('printing history')
        self.output(self._state.History)
        for key in list(self._state.History):
            if (self._state.History[key].split(';')[1] < str(slot_number)):
                del self._state.History[key]
        self.output('printing truncated history')
        self._state.logger.info((str(self._id) + 'Truncated the history'))
        self.output(self._state.History)

    def _Replica_handler_1315(self, cKM, rKM, olympus):
        self._state.replicaKM = rKM
        self._state.clientKM = cKM
    _Replica_handler_1315._labels = None
    _Replica_handler_1315._notlabels = None

    def _Replica_handler_1493(self, cp_slot, checkpoint_proof, p_id):
        if (self._state.state == 'ACTIVE'):
            self.output('received completed checkpoint proof should validate and truncate history')
            self.output(checkpoint_proof)
            self.truncate_history(cp_slot)
            if (not (self._state.isHead == True)):
                self.send(('completed_cp', cp_slot, checkpoint_proof), to=self._state.predecessor)
            self._state.cccslot = cp_slot
            self._state.c_cp_proof = checkpoint_proof
    _Replica_handler_1493._labels = None
    _Replica_handler_1493._notlabels = None

    def _Replica_handler_1545(self, cp_slot, checkpoint_proof, p_id):
        if (self._state.state == 'ACTIVE'):
            if (self._state.current_slot >= cp_slot):
                checkpoint_proof[cp_slot].append(self._state.mod_cp_hash)
                if (not (self._state.isTail == True)):
                    self.output('received checkpoint, appended self hash')
                    self.output(checkpoint_proof)
                    self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                    self.send(('checkpoint', cp_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self.output('In tail added self hash now checking validity')
                    self.output(checkpoint_proof)
                    if self.validate_checkpoint_proof(checkpoint_proof, cp_slot):
                        self.output('Checkpoint proof complete. Sending cp back in the chain')
                        self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                        self.truncate_history(cp_slot)
                        self.send(('completed_cp', cp_slot, checkpoint_proof), to=self._state.predecessor)
                        self._state.cccslot = cp_slot
                        self._state.c_cp_proof = checkpoint_proof
                    else:
                        self.output('Found error in the checkpoint proof, call for reconfiguration')
                        self.output('Actually the result shuttle will anyway cause reconfig request in this case')
            else:
                self.output('Saving the checkpoint until slot reaches required value')
                self._state.chcslot = cp_slot
                self._state.h_cp_proof = checkpoint_proof
    _Replica_handler_1545._labels = None
    _Replica_handler_1545._notlabels = None

    def _Replica_handler_1678(self, k_v, client_id, requestID, p_id):
        cmd = (((('put(' + k_v[0]) + ',') + k_v[1]) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + 'from') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            self._state.fail_flag = self.check_if_failure(str(client_id), 'client_request')
            if (self.checkIfRidPresentInHistory(requestID) == False):
                if self._state.isHead:
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'put', k_v)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + ' is ') + os))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_operation')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_operation failure'))
                        self.output('injecting Change_operation Failure')
                        os = self.getCorruptStatement(slot, 'get', ['x'])
                        enc_os = self.encodeStatement(os)
                        self._state.curr_fail_op = ''
                    else:
                        enc_os = self.encodeStatement(os)
                    self._state.db[k_v[0]] = k_v[1]
                    orderProof = {}
                    orderProof[requestID] = [enc_os]
                    result_statement = ''
                    result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_result')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_result failure'))
                        self.output('injecting change_result Failure')
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        self._state.curr_fail_op = ''
                    resultProof = {}
                    resultProof[requestID] = [result_statement]
                    OrderShuttle = [orderProof, resultProof]
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'drop_result_statement')):
                        self._state.logger.info((str(self._id) + ' Injecting drop_result_statement failure'))
                        self.output('injecting drop_result_statement Failure')
                        OrderShuttle[1][requestID].pop(0)
                        self._state.curr_fail_op = ''
                    self.send(('put', k_v, client_id, requestID, OrderShuttle), to=self._state.successor)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        checkpoint_proof = {}
                        checkpoint_proof[self._state.current_slot] = [self.get_hash()]
                        self._state.logger.info((str(self._id) + ' Checkpoint reached sending proof to successor'))
                        self.output(checkpoint_proof)
                        self.send(('checkpoint', self._state.current_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self.output('replica says retransmission')
                    self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                    if (requestID in self._state.resultCache):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                        self.send(('put_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                    else:
                        self._state.logger.info((str(self._id) + ' result is not in cache'))
                        self._state.retran_flag = 0
                        self._state.ReTransmittedRequest.append(requestID)
                        self._state.logger.info((str(self._id) + ' Sending the operation to head and waiting for the result shuttle to come back'))
                        self.send(('put', k_v, client_id, requestID), to=self._state.headReplica)
                        super()._label('_st_label_2098', block=False)
                        _st_label_2098 = 0
                        self._timer_start()
                        while (_st_label_2098 == 0):
                            _st_label_2098 += 1
                            if (self._state.retran_flag == 1):
                                self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                                self.send(('put_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                                self._state.retran_flag = 0
                                _st_label_2098 += 1
                            elif self._timer_expired:
                                self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                                self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                                _st_label_2098 += 1
                            else:
                                super()._label('_st_label_2098', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                                _st_label_2098 -= 1
            else:
                self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                if (requestID in self._state.resultCache):
                    self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                    self.send(('put_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                else:
                    self._state.logger.info((str(self._id) + ' result is not in cache'))
                    self._state.retran_flag = 0
                    self._state.ReTransmittedRequest.append(requestID)
                    self._state.logger.info((str(self._id) + ' waiting for the result shuttle to come back'))
                    super()._label('_st_label_2229', block=False)
                    _st_label_2229 = 0
                    self._timer_start()
                    while (_st_label_2229 == 0):
                        _st_label_2229 += 1
                        if (self._state.retran_flag == 1):
                            self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                            self.send(('put_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                            self._state.retran_flag = 0
                            _st_label_2229 += 1
                        elif self._timer_expired:
                            self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                            self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                            _st_label_2229 += 1
                        else:
                            super()._label('_st_label_2229', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                            _st_label_2229 -= 1
        else:
            self.output('Replica is immutable')
            self.send(('immutable', requestID), to=client_id)
    _Replica_handler_1678._labels = None
    _Replica_handler_1678._notlabels = None

    def _Replica_handler_2298(self, k_v, client_id, requestID, OrderShuttle, p_id):
        cmd = (((('put(' + k_v[0]) + ',') + k_v[1]) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            self._state.fail_flag = self.check_if_failure(str(client_id), 'forwarded_request')
            if (self._state.fail_flag == False):
                self._state.fail_flag = self.check_if_failure(str(client_id), 'shuttle')
            if (not (self._state.isHead == True)):
                if (self.verifyOrderProof(OrderShuttle[0], requestID) == True):
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'put', k_v)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_operation')):
                        self._state.logger.info((str(self._id) + ' injecting the change_operation failure'))
                        self.output('injecting change_operation Failure')
                        os = self.getCorruptStatement(slot, 'get', ['x'])
                        enc_os = self.encodeStatement(os)
                        self._state.curr_fail_op = ''
                    else:
                        enc_os = self.encodeStatement(os)
                    self._state.db[k_v[0]] = k_v[1]
                    OrderShuttle[0][requestID].append(enc_os)
                    result_statement = ''
                    result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_result')):
                        self.output('injecting change_result Failure')
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        self._state.curr_fail_op = ''
                    OrderShuttle[1][requestID].append(result_statement)
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'drop_result_statement')):
                        self._state.logger.info((str(self._id) + ' Injecting the drop_result_statement failure'))
                        self.output('injecting drop_result_statement Failure')
                        OrderShuttle[1][requestID].pop(0)
                        self._state.curr_fail_op = ''
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        self._state.mod_cp_hash = self.get_hash()
                        if ((not (self._state.chcslot == (- 1))) and (self._state.chcslot == self._state.current_slot)):
                            self._state.h_cp_proof[self._state.chcslot].append(self._state.mod_cp_hash)
                            self._state.send_cp = 1
                    if (not (self._state.isTail == True)):
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                        self.send(('put', k_v, client_id, requestID, OrderShuttle), to=self._state.successor)
                        if (self._state.send_cp == 1):
                            self.output(self._state.h_cp_proof)
                            self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                            self.send(('checkpoint', self._state.chcslot, self._state.h_cp_proof), to=self._state.successor)
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                    else:
                        self._state.logger.info(((str(self._id) + ' sending the result shuttle to client: ') + str(client_id)))
                        self.send(('put_result', OrderShuttle[1], requestID), to=client_id)
                        self._state.logger.info(((str(self._id) + ' send the result shuttle back in the chain to: ') + str(self._state.predecessor)))
                        self.send(('result_back', OrderShuttle[1], requestID, client_id), to=self._state.predecessor)
                        if (self._state.send_cp == 1):
                            if self.validate_checkpoint_proof(self._state.h_cp_proof, self._state.chcslot):
                                self.output('Checkpoint proof complete. Sending cp back in the chain')
                                self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                                self.truncate_history(self._state.chcslot)
                                self.send(('completed_cp', self._state.chcslot, self._state.h_cp_proof), to=self._state.predecessor)
                                self._state.cccslot = self._state.chcslot
                                self._state.c_cp_proof = self._state.h_cp_proof
                            else:
                                self.output('Found error in the checkpoint proof, call for reconfiguration')
                                self.output('Actually the result shuttle will anyway cause reconfig request in this case')
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                else:
                    self._state.logger.info((str(self._id) + ' There orderProof is not correct. Becoming IMMUTABLE and sending reconfiguration request to olympus'))
                    self.output('Dropping invalid request')
                    self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_2298._labels = None
    _Replica_handler_2298._notlabels = None

    def _Replica_handler_2869(self, key, client_id, requestID, p_id):
        cmd = (('get(' + key) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            self._state.fail_flag = self.check_if_failure(str(client_id), 'client_request')
            if (self.checkIfRidPresentInHistory(requestID) == False):
                if self._state.isHead:
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'get', [key])
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_operation')):
                        self._state.logger.info((str(self._id) + ' injecting the change_operation failure'))
                        self.output('injecting Change_operation Failure')
                        os = self.getCorruptStatement(slot, 'get', ['x'])
                        enc_os = self.encodeStatement(os)
                        self._state.curr_fail_op = ''
                    else:
                        enc_os = self.encodeStatement(os)
                    orderProof = {}
                    orderProof[requestID] = [enc_os]
                    result_statement = ''
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_result')):
                        self._state.logger.info((str(self._id) + ' injecting the change_result failure'))
                        self.output('injecting change_result Failure')
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        self._state.curr_fail_op = ''
                    elif (key in self._state.db):
                        result_statement = self.encodeStatement(((str(self._id) + ';') + self._state.db[key]))
                    else:
                        result_statement = self.encodeStatement((str(self._id) + ';'))
                    resultProof = {}
                    resultProof[requestID] = [result_statement]
                    OrderShuttle = [orderProof, resultProof]
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'drop_result_statement')):
                        self._state.logger.info((str(self._id) + ' injecting the drop_result_statement failure'))
                        self.output('injecting drop_result_statement Failure')
                        OrderShuttle[1][requestID].pop(0)
                        self._state.curr_fail_op = ''
                    self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                    self.send(('get', key, client_id, requestID, OrderShuttle), to=self._state.successor)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        checkpoint_proof = {}
                        checkpoint_proof[self._state.current_slot] = [self.get_hash()]
                        self._state.logger.info((str(self._id) + ' Checkpoint reached sending proof to successor'))
                        self.output(checkpoint_proof)
                        self.send(('checkpoint', self._state.current_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                    if (requestID in self._state.resultCache):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                        self.send(('get_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                    else:
                        self._state.logger.info((str(self._id) + ' result is not in cache'))
                        self._state.retran_flag = 0
                        self._state.ReTransmittedRequest.append(requestID)
                        self._state.logger.info((str(self._id) + ' Sending the operation to head and waiting for the result shuttle to come back'))
                        self.send(('get', key, client_id, requestID), to=self._state.headReplica)
                        super()._label('_st_label_3303', block=False)
                        _st_label_3303 = 0
                        self._timer_start()
                        while (_st_label_3303 == 0):
                            _st_label_3303 += 1
                            if (self._state.retran_flag == 1):
                                self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                                self.send(('get_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                                self._state.retran_flag = 0
                                _st_label_3303 += 1
                            elif self._timer_expired:
                                self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                                self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                                _st_label_3303 += 1
                            else:
                                super()._label('_st_label_3303', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                                _st_label_3303 -= 1
            else:
                self._state.logger.info((str(self._id) + ' result is not in cache'))
                self._state.retran_flag = 0
                self._state.ReTransmittedRequest.append(requestID)
                self._state.logger.info((str(self._id) + ' waiting for the result shuttle to come back'))
                super()._label('_st_label_3393', block=False)
                _st_label_3393 = 0
                self._timer_start()
                while (_st_label_3393 == 0):
                    _st_label_3393 += 1
                    if (self._state.retran_flag == 1):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                        self.send(('get_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                        self._state.retran_flag = 0
                        _st_label_3393 += 1
                    elif self._timer_expired:
                        self._state.logger.info((str(self._id) + ' timed out. Becomes immutable and sends the reconfiguration request to olympus'))
                        self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                        _st_label_3393 += 1
                    else:
                        super()._label('_st_label_3393', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                        _st_label_3393 -= 1
        else:
            self.output('Replica is immutable')
            self.send(('immutable', requestID), to=client_id)
    _Replica_handler_2869._labels = None
    _Replica_handler_2869._notlabels = None

    def _Replica_handler_3462(self, key, client_id, requestID, OrderShuttle, p_id):
        cmd = (('get(' + key) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            self._state.fail_flag = self.check_if_failure(str(client_id), 'forwarded_request')
            if (self._state.fail_flag == False):
                self._state.fail_flag = self.check_if_failure(str(client_id), 'shuttle')
            if (not (self._state.isHead == True)):
                if (self.verifyOrderProof(OrderShuttle[0], requestID) == True):
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'get', [key])
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_operation')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_operation failure'))
                        self.output('injecting Change_operation Failure')
                        os = self.getCorruptStatement(slot, 'get', ['x'])
                        enc_os = self.encodeStatement(os)
                        self._state.curr_fail_op = ''
                    else:
                        enc_os = self.encodeStatement(os)
                    OrderShuttle[0][requestID].append(enc_os)
                    result_statement = ''
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_result')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_result failure'))
                        self.output('injecting change_result Failure')
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        self._state.curr_fail_op = ''
                    elif (key in self._state.db):
                        result_statement = self.encodeStatement(((str(self._id) + ';') + self._state.db[key]))
                    else:
                        result_statement = self.encodeStatement((str(self._id) + ';'))
                    OrderShuttle[1][requestID].append(result_statement)
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'drop_result_statement')):
                        self._state.logger.info((str(self._id) + ' Injecting the drop_result_statement failure'))
                        self.output('injecting drop_result_statement Failure')
                        OrderShuttle[1][requestID].pop(0)
                        self._state.curr_fail_op = ''
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        self._state.mod_cp_hash = self.get_hash()
                        if ((not (self._state.chcslot == (- 1))) and (self._state.chcslot == self._state.current_slot)):
                            self._state.h_cp_proof[self._state.chcslot].append(self._state.mod_cp_hash)
                            self._state.send_cp = 1
                    if (not (self._state.isTail == True)):
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                        self.send(('get', key, client_id, requestID, OrderShuttle), to=self._state.successor)
                        if (self._state.send_cp == 1):
                            self.output(self._state.h_cp_proof)
                            self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                            self.send(('checkpoint', self._state.chcslot, self._state.h_cp_proof), to=self._state.successor)
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                    else:
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(client_id)))
                        self.send(('get_result', OrderShuttle[1], requestID), to=client_id)
                        self._state.logger.info(((str(self._id) + ' sending result shuttle forward to ') + str(self._state.predecessor)))
                        self.send(('result_back', OrderShuttle[1], requestID, client_id), to=self._state.predecessor)
                        if (self._state.send_cp == 1):
                            if self.validate_checkpoint_proof(self._state.h_cp_proof, self._state.chcslot):
                                self.output('Checkpoint proof complete. Sending cp back in the chain')
                                self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                                self.truncate_history(self._state.chcslot)
                                self.send(('completed_cp', self._state.chcslot, self._state.h_cp_proof), to=self._state.predecessor)
                                self._state.cccslot = self._state.chcslot
                                self._state.c_cp_proof = self._state.h_cp_proof
                            else:
                                self.output('Found error in the checkpoint proof, call for reconfiguration')
                                self.output('Actually the result shuttle will anyway cause reconfig request in this case')
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                else:
                    self._state.logger.info((str(self._id) + ' There orderProof is not correct. Becoming IMMUTABLE and sending reconfiguration request to olympus'))
                    self.output('Dropping invalid request')
                    self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_3462._labels = None
    _Replica_handler_3462._notlabels = None

    def _Replica_handler_4043(self, args, client_id, requestID, p_id):
        cmd = (('slice(' + str(args)) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            self._state.fail_flag = self.check_if_failure(str(client_id), 'client_request')
            if (self.checkIfRidPresentInHistory(requestID) == False):
                if self._state.isHead:
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'slice', args)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    orderProof = {}
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_operation')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_operation failure'))
                        self.output('injecting Change_operation Failure')
                        os = self.getCorruptStatement(slot, 'get', ['x'])
                        enc_os = self.encodeStatement(os)
                        self._state.curr_fail_op = ''
                    else:
                        enc_os = self.encodeStatement(os)
                    orderProof[requestID] = [enc_os]
                    result_statement = ''
                    (start, end) = args[1].split(':')
                    if (args[0] in self._state.db):
                        val = self._state.db[args[0]]
                        if ((int(start) >= 0) and (int(end) <= len(val))):
                            val = val[int(start):int(end)]
                            self._state.db[args[0]] = val
                            result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        else:
                            result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    else:
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_result')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_result failure'))
                        self.output('injecting change_result Failure')
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        self._state.curr_fail_op = ''
                    resultProof = {}
                    resultProof[requestID] = [result_statement]
                    OrderShuttle = [orderProof, resultProof]
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'drop_result_statement')):
                        self._state.logger.info((str(self._id) + ' Injecting the drop_result_statement failure'))
                        self.output('injecting drop_result_statement Failure')
                        OrderShuttle[1][requestID].pop(0)
                        self._state.curr_fail_op = ''
                    self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                    self.send(('slice', args, client_id, requestID, OrderShuttle), to=self._state.successor)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        checkpoint_proof = {}
                        checkpoint_proof[self._state.current_slot] = [self.get_hash()]
                        self._state.logger.info((str(self._id) + ' Checkpoint reached sending proof to successor'))
                        self.output(checkpoint_proof)
                        self.send(('checkpoint', self._state.current_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                    if (requestID in self._state.resultCache):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                        self.send(('slice_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                    else:
                        self._state.logger.info((str(self._id) + ' result is not in cache'))
                        self._state.retran_flag = 0
                        self._state.ReTransmittedRequest.append(requestID)
                        self._state.logger.info((str(self._id) + ' Sending the operation to head and waiting for the result shuttle to come back'))
                        self.send(('slice', args, client_id, requestID), to=self._state.headReplica)
                        super()._label('_st_label_4544', block=False)
                        _st_label_4544 = 0
                        self._timer_start()
                        while (_st_label_4544 == 0):
                            _st_label_4544 += 1
                            if (self._state.retran_flag == 1):
                                self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                                self.send(('slice_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                                self._state.retran_flag = 0
                                _st_label_4544 += 1
                            elif self._timer_expired:
                                self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                                self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                                _st_label_4544 += 1
                            else:
                                super()._label('_st_label_4544', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                                _st_label_4544 -= 1
            else:
                self._state.logger.info((str(self._id) + ' result is not in cache'))
                self._state.retran_flag = 0
                self._state.ReTransmittedRequest.append(requestID)
                self._state.logger.info((str(self._id) + ' waiting for the result shuttle to come back'))
                super()._label('_st_label_4634', block=False)
                _st_label_4634 = 0
                self._timer_start()
                while (_st_label_4634 == 0):
                    _st_label_4634 += 1
                    if (self._state.retran_flag == 1):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                        self.send(('slice_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                        self._state.retran_flag = 0
                        _st_label_4634 += 1
                    elif self._timer_expired:
                        self._state.logger.info((str(self._id) + ' timed out. Becomes immutable and sends the reconfiguration request to olympus'))
                        self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                        _st_label_4634 += 1
                    else:
                        super()._label('_st_label_4634', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                        _st_label_4634 -= 1
        else:
            self.output('Replica is immutable')
            self.send(('immutable', requestID), to=client_id)
    _Replica_handler_4043._labels = None
    _Replica_handler_4043._notlabels = None

    def _Replica_handler_4703(self, args, client_id, requestID, OrderShuttle, p_id):
        cmd = (('slice(' + str(args)) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            self._state.fail_flag = self.check_if_failure(str(client_id), 'forwarded_request')
            if (self._state.fail_flag == False):
                self._state.fail_flag = self.check_if_failure(str(client_id), 'shuttle')
            if (not (self._state.isHead == True)):
                if (self.verifyOrderProof(OrderShuttle[0], requestID) == True):
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'slice', args)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_operation')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_operation failure'))
                        self.output('injecting Change_operation Failure')
                        os = self.getCorruptStatement(slot, 'get', ['x'])
                        enc_os = self.encodeStatement(os)
                        self._state.curr_fail_op = ''
                    else:
                        enc_os = self.encodeStatement(os)
                    OrderShuttle[0][requestID].append(enc_os)
                    result_statement = ''
                    (start, end) = args[1].split(':')
                    if (args[0] in self._state.db):
                        val = self._state.db[args[0]]
                        if ((int(start) >= 0) and (int(end) <= len(val))):
                            val = val[int(start):int(end)]
                            self._state.db[args[0]] = val
                            result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        else:
                            result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    else:
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_result')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_result failure'))
                        self.output('injecting change_result Failure')
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        self._state.curr_fail_op = ''
                    OrderShuttle[1][requestID].append(result_statement)
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'drop_result_statement')):
                        self._state.logger.info((str(self._id) + ' Injecting the drop_result_statement failure'))
                        self.output('injecting drop_result_statement Failure')
                        OrderShuttle[1][requestID].pop(0)
                        self._state.curr_fail_op = ''
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        self._state.mod_cp_hash = self.get_hash()
                        if ((not (self._state.chcslot == (- 1))) and (self._state.chcslot == self._state.current_slot)):
                            self._state.h_cp_proof[self._state.chcslot].append(self._state.mod_cp_hash)
                            self._state.send_cp = 1
                    if (not (self._state.isTail == True)):
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                        self.send(('slice', args, client_id, requestID, OrderShuttle), to=self._state.successor)
                        if (self._state.send_cp == 1):
                            self.output(self._state.h_cp_proof)
                            self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                            self.send(('checkpoint', self._state.chcslot, self._state.h_cp_proof), to=self._state.successor)
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                    else:
                        self._state.logger.info(((str(self._id) + ' sending result shuttle to ') + str(client_id)))
                        self.send(('slice_result', OrderShuttle[1], requestID), to=client_id)
                        self._state.logger.info(((str(self._id) + ' sending result shuttle back to ') + str(self._state.predecessor)))
                        self.send(('result_back', OrderShuttle[1], requestID, client_id), to=self._state.predecessor)
                        if (self._state.send_cp == 1):
                            if self.validate_checkpoint_proof(self._state.h_cp_proof, self._state.chcslot):
                                self.output('Checkpoint proof complete. Sending cp back in the chain')
                                self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                                self.truncate_history(self._state.chcslot)
                                self.send(('completed_cp', self._state.chcslot, self._state.h_cp_proof), to=self._state.predecessor)
                                self._state.cccslot = self._state.chcslot
                                self._state.c_cp_proof = self._state.h_cp_proof
                            else:
                                self.output('Found error in the checkpoint proof, call for reconfiguration')
                                self.output('Actually the result shuttle will anyway cause reconfig request in this case')
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                else:
                    self._state.logger.info((str(self._id) + ' There orderProof is not correct. Becoming IMMUTABLE and sending reconfiguration request to olympus'))
                    self.output('Dropping invalid request')
                    self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_4703._labels = None
    _Replica_handler_4703._notlabels = None

    def _Replica_handler_5351(self, args, client_id, requestID, p_id):
        cmd = (('append(' + str(args)) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            self._state.fail_flag = self.check_if_failure(str(client_id), 'client_request')
            if (self.checkIfRidPresentInHistory(requestID) == False):
                if self._state.isHead:
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'append', args)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    orderProof = {}
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_operation')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_operation failure'))
                        self.output('injecting Change_operation Failure')
                        os = self.getCorruptStatement(slot, 'get', ['x'])
                        enc_os = self.encodeStatement(os)
                        self._state.curr_fail_op = ''
                    else:
                        enc_os = self.encodeStatement(os)
                    orderProof[requestID] = [enc_os]
                    result_statement = ''
                    if (args[0] in self._state.db):
                        val = self._state.db[args[0]]
                        val = ((val + ' ') + args[1])
                        self._state.db[args[0]] = val
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                    else:
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_result')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_result failure'))
                        self.output('injecting change_result Failure')
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        self._state.curr_fail_op = ''
                    resultProof = {}
                    resultProof[requestID] = [result_statement]
                    OrderShuttle = [orderProof, resultProof]
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'drop_result_statement')):
                        self._state.logger.info((str(self._id) + ' Injecting the drop_result_statement failure'))
                        self.output('injecting drop_result_statement Failure')
                        OrderShuttle[1][requestID].pop(0)
                        self._state.curr_fail_op = ''
                    self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                    self.send(('append', args, client_id, requestID, OrderShuttle), to=self._state.successor)
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        checkpoint_proof = {}
                        checkpoint_proof[self._state.current_slot] = [self.get_hash()]
                        self._state.logger.info((str(self._id) + ' Checkpoint reached sending proof to successor'))
                        self.output(checkpoint_proof)
                        self.send(('checkpoint', self._state.current_slot, checkpoint_proof), to=self._state.successor)
                else:
                    self._state.logger.info((str(self._id) + ' received the broadcast from client.'))
                    if (requestID in self._state.resultCache):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation present in result cache. sending it to client :') + str(client_id)))
                        self.send(('append_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                    else:
                        self._state.logger.info((str(self._id) + ' result is not in cache'))
                        self._state.retran_flag = 0
                        self._state.ReTransmittedRequest.append(requestID)
                        self._state.logger.info((str(self._id) + ' Sending the operation to head and waiting for the result shuttle to come back'))
                        self.send(('append', args, client_id, requestID), to=self._state.headReplica)
                        super()._label('_st_label_5814', block=False)
                        _st_label_5814 = 0
                        self._timer_start()
                        while (_st_label_5814 == 0):
                            _st_label_5814 += 1
                            if (self._state.retran_flag == 1):
                                self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                                self.send(('append_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                                self._state.retran_flag = 0
                                _st_label_5814 += 1
                            elif self._timer_expired:
                                self._state.logger.info((str(self._id) + ' timed out. Sending reconfiguration request to olympus'))
                                self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                                _st_label_5814 += 1
                            else:
                                super()._label('_st_label_5814', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                                _st_label_5814 -= 1
            else:
                self._state.logger.info((str(self._id) + ' result is not in cache'))
                self._state.retran_flag = 0
                self._state.ReTransmittedRequest.append(requestID)
                self._state.logger.info((str(self._id) + ' waiting for the result shuttle to come back'))
                super()._label('_st_label_5904', block=False)
                _st_label_5904 = 0
                self._timer_start()
                while (_st_label_5904 == 0):
                    _st_label_5904 += 1
                    if (self._state.retran_flag == 1):
                        self._state.logger.info(((str(self._id) + ' the result shuttle for broadcasted operation  received. sending it to client :') + str(client_id)))
                        self.send(('append_result', {requestID: self._state.resultCache[requestID]}, requestID), to=client_id)
                        self._state.retran_flag = 0
                        _st_label_5904 += 1
                    elif self._timer_expired:
                        self._state.logger.info((str(self._id) + ' timed out. Becomes immutable and sends the reconfiguration request to olympus'))
                        self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
                        _st_label_5904 += 1
                    else:
                        super()._label('_st_label_5904', block=True, timeout=(self._state.conf['head_timeout'] / 1000))
                        _st_label_5904 -= 1
        else:
            self.output('Replica is immutable')
            self.send(('immutable', requestID), to=client_id)
    _Replica_handler_5351._labels = None
    _Replica_handler_5351._notlabels = None

    def _Replica_handler_5973(self, args, client_id, requestID, OrderShuttle, p_id):
        cmd = (('append(' + str(args)) + ')')
        self._state.logger.info(((((str(self._id) + ' Received ') + cmd) + ' from: ') + str(p_id)))
        if (self._state.state == 'ACTIVE'):
            if (not (self._state.isHead == True)):
                self._state.fail_flag = self.check_if_failure(str(client_id), 'forwarded_request')
                if (self._state.fail_flag == False):
                    self._state.fail_flag = self.check_if_failure(str(client_id), 'shuttle')
                if (self.verifyOrderProof(OrderShuttle[0], requestID) == True):
                    slot = self.get_slot_number()
                    os = self.orderCommand(slot, 'append', args)
                    if (not (os == 'error')):
                        self._state.History[requestID] = os
                    self._state.logger.info(((((str(self._id) + ' The order statement for ') + requestID) + 'is: ') + os))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_operation')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_operation failure'))
                        self.output('injecting Change_operation Failure')
                        os = self.getCorruptStatement(slot, 'get', ['x'])
                        enc_os = self.encodeStatement(os)
                        self._state.curr_fail_op = ''
                    else:
                        enc_os = self.encodeStatement(os)
                    OrderShuttle[0][requestID].append(enc_os)
                    result_statement = ''
                    if (args[0] in self._state.db):
                        val = self._state.db[args[0]]
                        val = ((val + ' ') + args[1])
                        self._state.db[args[0]] = val
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                    else:
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'FAIL'))
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'change_result')):
                        self._state.logger.info((str(self._id) + ' Injecting the change_result failure'))
                        self.output('injecting change_result Failure')
                        result_statement = self.encodeStatement(((str(self._id) + ';') + 'OK'))
                        self._state.curr_fail_op = ''
                    OrderShuttle[1][requestID].append(result_statement)
                    if ((self._state.fail_flag == True) and (self._state.curr_fail_op == 'drop_result_statement')):
                        self._state.logger.info((str(self._id) + ' Injecting the drop_result_statement failure'))
                        self.output('injecting drop_result_statement Failure')
                        OrderShuttle[1][requestID].pop(0)
                        self._state.curr_fail_op = ''
                    if ((self._state.current_slot % self._state.cp_interval) == 0):
                        self._state.mod_cp_hash = self.get_hash()
                        if ((not (self._state.chcslot == (- 1))) and (self._state.chcslot == self._state.current_slot)):
                            self._state.h_cp_proof[self._state.chcslot].append(self._state.mod_cp_hash)
                            self._state.send_cp = 1
                    if (not (self._state.isTail == True)):
                        self._state.logger.info(((str(self._id) + ' sending order shuttle forward to ') + str(self._state.successor)))
                        self.send(('append', args, client_id, requestID, OrderShuttle), to=self._state.successor)
                        if (self._state.send_cp == 1):
                            self.output(self._state.h_cp_proof)
                            self._state.logger.info(((str(self._id) + 'sending checkpoint proof forward to ') + str(self._state.successor)))
                            self.send(('checkpoint', self._state.chcslot, self._state.h_cp_proof), to=self._state.successor)
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                    else:
                        self._state.logger.info(((str(self._id) + ' sending result shuttle to ') + str(client_id)))
                        self.send(('append_result', OrderShuttle[1], requestID), to=client_id)
                        self._state.logger.info(((str(self._id) + ' sending result shuttle back to ') + str(self._state.predecessor)))
                        self.send(('result_back', OrderShuttle[1], requestID, client_id), to=self._state.predecessor)
                        if (self._state.send_cp == 1):
                            if self.validate_checkpoint_proof(self._state.h_cp_proof, self._state.chcslot):
                                self.output('Checkpoint proof complete. Sending cp back in the chain')
                                self._state.logger.info(((str(self._id) + 'sending checkpoint proof back in the chain ') + str(self._state.predecessor)))
                                self.truncate_history(self._state.chcslot)
                                self.send(('completed_cp', self._state.chcslot, self._state.h_cp_proof), to=self._state.predecessor)
                                self._state.cccslot = self._state.chcslot
                                self._state.c_cp_proof = self._state.h_cp_proof
                            else:
                                self.output('Found error in the checkpoint proof, call for reconfiguration')
                                self.output('Actually the result shuttle will anyway cause reconfig request in this case')
                            self._state.send_cp = 0
                            self._state.chcslot = (- 1)
                            self._state.h_cp_proof = {}
                else:
                    self._state.logger.info((str(self._id) + ' There orderProof is not correct. Becoming IMMUTABLE and sending reconfiguration request to olympus'))
                    self.output('Dropping invalid request')
                    self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_5973._labels = None
    _Replica_handler_5973._notlabels = None

    def _Replica_handler_6583(self, client_id):
        self.send(('dict_reply', self._state.db), to=client_id)
    _Replica_handler_6583._labels = None
    _Replica_handler_6583._notlabels = None

    def _Replica_handler_6600(self, cp_sn, checkpoint_proof, p_id):
        self._state.chcslot = cp_sn
        self._state.h_cp_proof = checkpoint_proof
    _Replica_handler_6600._labels = None
    _Replica_handler_6600._notlabels = None

    def _Replica_handler_6624(self, result_shuttle, requestID, clientID, p_id):
        cond = True
        resultStatements = result_shuttle[requestID]
        i = 0
        for key in self._state.replicaKM:
            try:
                self._state.replicaKM[key].verify(resultStatements[i])
                i = (i + 1)
            except:
                cond = False
                break
        if (cond == True):
            if (requestID in self._state.ReTransmittedRequest):
                self.output('Sending back the response of retransmitted request to : CLIENT')
                self._state.resultCache[requestID] = result_shuttle[requestID]
                if (self._state.isHead == False):
                    self.send(('result_back', result_shuttle, requestID), to=self._state.predecessor)
                self._state.retran_flag = 1
            else:
                self._state.resultCache[requestID] = result_shuttle[requestID]
                if (self._state.isHead == False):
                    self.send(('result_back', result_shuttle, requestID), to=self._state.predecessor)
        else:
            self.output('Needs reconfiguration as the result shuttle is inconsistent. The replica will become immutable.')
            self._state.logger.info((str(self._id) + ' Result shuttle not consistent. Sending reconfig request to oly'))
            self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_6624._labels = None
    _Replica_handler_6624._notlabels = None

    def _Replica_handler_6763(self, p, s, head, olympus):
        self._state.successor = s
        self._state.predecessor = p
        self._state.headReplica = head
        self._state.flag = 1
    _Replica_handler_6763._labels = None
    _Replica_handler_6763._notlabels = None

    def _Replica_handler_6799(self, olym):
        self._state.state = 'IMMUTABLE'
        self.send(('wedged_reply', self._id, self._state.History, self._state.c_cp_proof), to=olym)
    _Replica_handler_6799._labels = None
    _Replica_handler_6799._notlabels = None

    def _Replica_handler_6825(self, client):
        if (self._state.isHead == True):
            self._state.History[(str(self._id) + str(self._state.current_slot))] = (((str(self._id) + ';') + str(self._state.current_slot)) + ';put;movie;star')
            self._state.current_slot = (self._state.current_slot + 1)
            self._state.History[(str(self._id) + str(self._state.current_slot))] = (((str(self._id) + ';') + str(self._state.current_slot)) + ';put;movie;star')
        self.send(('reconfiguration', self._state.curr_config), to=self._state.olympus)
    _Replica_handler_6825._labels = None
    _Replica_handler_6825._notlabels = None
