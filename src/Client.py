# -*- generated by 1.0.9 -*-
import da
PatternExpr_1421 = da.pat.TuplePattern([da.pat.ConstantPattern('new_config'), da.pat.FreePattern('config'), da.pat.FreePattern('rkm'), da.pat.FreePattern('reps')])
PatternExpr_1432 = da.pat.FreePattern('olympus')
PatternExpr_1507 = da.pat.TuplePattern([da.pat.ConstantPattern('public_key_maps'), da.pat.FreePattern('cKM'), da.pat.FreePattern('rKM')])
PatternExpr_1516 = da.pat.FreePattern('olympus')
PatternExpr_1545 = da.pat.TuplePattern([da.pat.ConstantPattern('put_result'), da.pat.FreePattern('resultShuttle'), da.pat.FreePattern('requestID')])
PatternExpr_1554 = da.pat.FreePattern('tail_id')
PatternExpr_1687 = da.pat.TuplePattern([da.pat.ConstantPattern('get_result'), da.pat.FreePattern('resultShuttle'), da.pat.FreePattern('requestID')])
PatternExpr_1696 = da.pat.FreePattern('tail_id')
PatternExpr_1833 = da.pat.TuplePattern([da.pat.ConstantPattern('slice_result'), da.pat.FreePattern('resultShuttle'), da.pat.FreePattern('requestID')])
PatternExpr_1842 = da.pat.FreePattern('tail_id')
PatternExpr_1977 = da.pat.TuplePattern([da.pat.ConstantPattern('append_result'), da.pat.FreePattern('resultShuttle'), da.pat.FreePattern('requestID')])
PatternExpr_1986 = da.pat.FreePattern('tail_id')
PatternExpr_2112 = da.pat.TuplePattern([da.pat.ConstantPattern('currentConfig'), da.pat.FreePattern('replicas')])
PatternExpr_2118 = da.pat.FreePattern('olympus_id')
PatternExpr_2129 = da.pat.TuplePattern([da.pat.ConstantPattern('dict_reply'), da.pat.FreePattern('db')])
PatternExpr_2136 = da.pat.FreePattern('p_id')
PatternExpr_2162 = da.pat.TuplePattern([da.pat.ConstantPattern('generated_key'), da.pat.FreePattern('pri_key')])
PatternExpr_2169 = da.pat.FreePattern('oly')
PatternExpr_2184 = da.pat.TuplePattern([da.pat.ConstantPattern('immutable'), da.pat.FreePattern('req_id')])
PatternExpr_2191 = da.pat.FreePattern('rid')
_config_object = {}
import random
import time
import sys
import logging
replica = da.import_da('Replica')
olympus = da.import_da('Olympus')

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_1421, sources=[PatternExpr_1432], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1420]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_1507, sources=[PatternExpr_1516], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1506]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_1545, sources=[PatternExpr_1554], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1544]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_1687, sources=[PatternExpr_1696], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1686]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_1833, sources=[PatternExpr_1842], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1832]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_5', PatternExpr_1977, sources=[PatternExpr_1986], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1976]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_6', PatternExpr_2112, sources=[PatternExpr_2118], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2111]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_7', PatternExpr_2129, sources=[PatternExpr_2136], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2128]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_8', PatternExpr_2162, sources=[PatternExpr_2169], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2161]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_9', PatternExpr_2184, sources=[PatternExpr_2191], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2183])])

    def setup(self, conf, oly, workload, cc, **rest_2550):
        super().setup(conf=conf, oly=oly, workload=workload, cc=cc, **rest_2550)
        self._state.conf = conf
        self._state.oly = oly
        self._state.workload = workload
        self._state.cc = cc
        self._state.replicas = {}
        self._state.flag = 0
        self._state.RTRequest = []
        self._state.private_key = ''
        self._state.replicaKM = {}
        self._state.clientKM = {}
        self._state.logger = None
        self._state.curr_config = self._state.cc
        self._state.reconfig = False
        self._state.reconfig_at = None
        self._state.head = None
        self._state.received_new_config = False

    def run(self):
        logger_file_name = ((self._state.conf['test_case_name'] + str(self._id).split(':')[1]) + '_c.txt')
        self._state.logger = self.get_logger('client', logger_file_name)
        self._state.logger.info((str(self._id) + ' sending get config request to olympus'))
        self.send(('getConfig', self._id), to=self._state.oly)
        super()._label('_st_label_349', block=False)
        _st_label_349 = 0
        while (_st_label_349 == 0):
            _st_label_349 += 1
            if (not (len(self._state.replicas) == 0)):
                _st_label_349 += 1
            else:
                super()._label('_st_label_349', block=True)
                _st_label_349 -= 1
        self._state.logger.info((str(self._id) + ' sending generate key request to olympus'))
        self.send('generate_keys', to=self._state.oly)
        super()._label('_st_label_371', block=False)
        _st_label_371 = 0
        while (_st_label_371 == 0):
            _st_label_371 += 1
            if (self._state.flag == 1):
                _st_label_371 += 1
            else:
                super()._label('_st_label_371', block=True)
                _st_label_371 -= 1
        self._state.flag = 0
        self._state.logger.info((str(self._id) + ' getting public key map from olympus'))
        self.send('get_public_key_maps', to=self._state.oly)
        super()._label('_st_label_396', block=False)
        _st_label_396 = 0
        while (_st_label_396 == 0):
            _st_label_396 += 1
            if (self._state.flag == 1):
                _st_label_396 += 1
            else:
                super()._label('_st_label_396', block=True)
                _st_label_396 -= 1
        self._state.flag = 0
        self._state.logger.info(((str(self._id) + ' the workload is : ') + str(self._state.workload)))
        self.output(' The workload is: ', self._state.workload)
        if (self._state.workload[0][0:6] == 'pseudo'):
            self._state.logger.info((str(self._id) + ' generating the pseudo random workload'))
            key_val = self._state.workload[0][13:(len(self._state.workload[0]) - 1)]
            seed = int(key_val.split(',')[0])
            opn = int(key_val.split(',')[1])
            self._state.workload = self.getPseudorandomWL(seed, opn)
            self.output(self._state.workload)
        rep = list(self._state.replicas)
        self._state.head = rep[0]
        opNum = 0
        f_b = 0
        prev_c = self._state.curr_config
        for op in self._state.workload:
            op_b = op[0:3]
            if (op_b == 'put'):
                key_val = op[4:(len(op) - 1)]
                args = self.getArguments(key_val)
                self._state.logger.info(((((str(self._id) + ' sending put operation with ') + str(key_val)) + ' to head :') + str(self._state.head)))
                self.send(('put', args, self._id, self.generateRequestId(opNum)), to=self._state.head)
                i = 0
                j = 0
                while (j < 2):
                    super()._label('_st_label_591', block=False)
                    _st_label_591 = 0
                    self._timer_start()
                    while (_st_label_591 == 0):
                        _st_label_591 += 1
                        if ((self._state.flag == 1) or (self._state.reconfig == True)):
                            self._state.flag = 0
                            if (self._state.reconfig == True):
                                self._state.logger.info((str(self._id) + ' Request lost in reconfig'))
                            break
                            _st_label_591 += 1
                        elif self._timer_expired:
                            time.sleep(((self._state.conf['client_timeout'] / 1000) - 1))
                            if (prev_c == self._state.curr_config):
                                self.output(("I'm the bastard : " + str(self._id)))
                                self.output(self._state.replicas)
                                self._state.logger.info((str(self._id) + ' Operation timeout. Broadcasting to all clients'))
                                self.output('Operation TimedOut. Broadcasting message to all clients')
                                self._state.RTRequest.append(self.generateRequestId(opNum))
                                for r in self._state.replicas:
                                    self.send(('get', args[0], self._id, self.generateRequestId(opNum)), to=r)
                            else:
                                self._state.logger.info((str(self._id) + ' Request lost in reconfig'))
                                break
                            j = (j + 1)
                            _st_label_591 += 1
                        else:
                            super()._label('_st_label_591', block=True, timeout=(self._state.conf['client_timeout'] / 1000))
                            _st_label_591 -= 1
                    else:
                        if (_st_label_591 != 2):
                            continue
                    if (_st_label_591 != 2):
                        break
                    i = (i + 1)
            elif (op_b == 'get'):
                key = op[4:(len(op) - 1)]
                args = self.getArguments(key)
                self._state.logger.info(((((str(self._id) + ' sending get operation with ') + args[0]) + ' to head :') + str(self._state.head)))
                self.send(('get', args[0], self._id, self.generateRequestId(opNum)), to=self._state.head)
                i = 0
                j = 0
                while (j < 2):
                    super()._label('_st_label_775', block=False)
                    _st_label_775 = 0
                    self._timer_start()
                    while (_st_label_775 == 0):
                        _st_label_775 += 1
                        if ((self._state.flag == 1) or (self._state.reconfig == True)):
                            self._state.flag = 0
                            if (self._state.reconfig == True):
                                self._state.logger.info((str(self._id) + ' Request lost in reconfig'))
                            break
                            _st_label_775 += 1
                        elif self._timer_expired:
                            time.sleep(((self._state.conf['client_timeout'] / 1000) - 1))
                            if (prev_c == self._state.curr_config):
                                self.output(("I'm the bastard : " + str(self._id)))
                                self.output(self._state.replicas)
                                self._state.logger.info((str(self._id) + ' Operation timeout. Broadcasting to all clients'))
                                self.output('Operation TimedOut. Broadcasting message to all clients')
                                self._state.RTRequest.append(self.generateRequestId(opNum))
                                for r in self._state.replicas:
                                    self.send(('get', args[0], self._id, self.generateRequestId(opNum)), to=r)
                            else:
                                self._state.logger.info((str(self._id) + ' Request lost in reconfig'))
                                break
                            j = (j + 2)
                            _st_label_775 += 1
                        else:
                            super()._label('_st_label_775', block=True, timeout=(self._state.conf['client_timeout'] / 1000))
                            _st_label_775 -= 1
                    else:
                        if (_st_label_775 != 2):
                            continue
                    if (_st_label_775 != 2):
                        break
                    i = (i + 1)
            elif (op_b == 'sli'):
                key_val = op[6:(len(op) - 1)]
                args = self.getArguments(key_val)
                self._state.logger.info(((((str(self._id) + ' sending slice operation with ') + str(args)) + ' to head :') + str(self._state.head)))
                self.send(('slice', args, self._id, self.generateRequestId(opNum)), to=self._state.head)
                i = 0
                j = 0
                while (j < 2):
                    super()._label('_st_label_955', block=False)
                    _st_label_955 = 0
                    self._timer_start()
                    while (_st_label_955 == 0):
                        _st_label_955 += 1
                        if ((self._state.flag == 1) or (self._state.reconfig == True)):
                            self._state.flag = 0
                            if (self._state.reconfig == True):
                                self._state.logger.info((str(self._id) + ' Request lost in reconfig'))
                            break
                            _st_label_955 += 1
                        elif self._timer_expired:
                            time.sleep(((self._state.conf['client_timeout'] / 1000) - 1))
                            if (prev_c == self._state.curr_config):
                                self.output(("I'm the bastard : " + str(self._id)))
                                self.output(self._state.replicas)
                                self._state.logger.info((str(self._id) + ' Operation timeout. Broadcasting to all clients'))
                                self.output('Operation TimedOut. Broadcasting message to all clients')
                                self._state.RTRequest.append(self.generateRequestId(opNum))
                                for r in self._state.replicas:
                                    self.send(('get', args[0], self._id, self.generateRequestId(opNum)), to=r)
                            else:
                                self._state.logger.info((str(self._id) + ' Request lost in reconfig'))
                                break
                            j = (j + 2)
                            _st_label_955 += 1
                        else:
                            super()._label('_st_label_955', block=True, timeout=(self._state.conf['client_timeout'] / 1000))
                            _st_label_955 -= 1
                    else:
                        if (_st_label_955 != 2):
                            continue
                    if (_st_label_955 != 2):
                        break
                    i = (i + 1)
            elif (op_b == 'app'):
                key_val = op[7:(len(op) - 1)]
                args = self.getArguments(key_val)
                self._state.logger.info(((((str(self._id) + ' sending append operation with ') + str(args)) + ' to head :') + str(self._state.head)))
                self.send(('append', args, self._id, self.generateRequestId(opNum)), to=self._state.head)
                i = 0
                j = 0
                while (j < 2):
                    super()._label('_st_label_1135', block=False)
                    _st_label_1135 = 0
                    self._timer_start()
                    while (_st_label_1135 == 0):
                        _st_label_1135 += 1
                        if ((self._state.flag == 1) or (self._state.reconfig == True)):
                            self._state.flag = 0
                            if (self._state.reconfig == True):
                                self._state.logger.info((str(self._id) + ' Request lost in reconfig'))
                            break
                            _st_label_1135 += 1
                        elif self._timer_expired:
                            time.sleep(((self._state.conf['client_timeout'] / 1000) - 1))
                            if (prev_c == self._state.curr_config):
                                self.output(("I'm the bastard : " + str(self._id)))
                                self.output(self._state.replicas)
                                self._state.logger.info((str(self._id) + ' Operation timeout. Broadcasting to all clients'))
                                self.output('Operation TimedOut. Broadcasting message to all clients')
                                self._state.RTRequest.append(self.generateRequestId(opNum))
                                for r in self._state.replicas:
                                    self.send(('get', args[0], self._id, self.generateRequestId(opNum)), to=r)
                            else:
                                self._state.logger.info((str(self._id) + ' Request lost in reconfig'))
                                break
                            j = (j + 2)
                            _st_label_1135 += 1
                        else:
                            super()._label('_st_label_1135', block=True, timeout=(self._state.conf['client_timeout'] / 1000))
                            _st_label_1135 -= 1
                    else:
                        if (_st_label_1135 != 2):
                            continue
                    if (_st_label_1135 != 2):
                        break
                    i = (i + 1)
            elif (op_b == 'rec'):
                self.send('reconfig', to=self._state.head)
                self._state.logger.info(((str(self._id) + ' Sending the reconfig trigger to head :') + str(self._state.head)))
                super()._label('_st_label_1278', block=False)
                _st_label_1278 = 0
                while (_st_label_1278 == 0):
                    _st_label_1278 += 1
                    if ((self._state.flag == 1) or (self._state.reconfig == True)):
                        self._state.flag = 0
                        _st_label_1278 += 1
                    else:
                        super()._label('_st_label_1278', block=True)
                        _st_label_1278 -= 1
                else:
                    if (_st_label_1278 != 2):
                        continue
                if (_st_label_1278 != 2):
                    break
            if (self._state.reconfig == True):
                self.output('Reconfiguration is underway. Ask olympus for reconfig request')
                rr = 0
                while (rr == 0):
                    self._state.logger.info((str(self._id) + ' Sending get_new_config request to Olympus'))
                    self.send(('need_new_config', self._state.curr_config), to=self._state.oly)
                    super()._label('_st_label_1327', block=False)
                    _st_label_1327 = 0
                    self._timer_start()
                    while (_st_label_1327 == 0):
                        _st_label_1327 += 1
                        if (self._state.received_new_config == True):
                            self._state.reconfig = False
                            self._state.logger.info((str(self._id) + ' Waiting for the configuration to reboot'))
                            time.sleep(((self._state.conf['client_timeout'] / 1000) - 1))
                            rr = 1
                            _st_label_1327 += 1
                        elif self._timer_expired:
                            self._state.logger.info((str(self._id) + ' Waiting for new configuration timed out.'))
                            _st_label_1327 += 1
                        else:
                            super()._label('_st_label_1327', block=True, timeout=(self._state.conf['client_timeout'] / 1000))
                            _st_label_1327 -= 1
                    else:
                        if (_st_label_1327 != 2):
                            continue
                    if (_st_label_1327 != 2):
                        break
                    self._state.logger.info((str(self._id) + ' Exited the loop.'))
            opNum = (opNum + 1)
        self.send('get_dict', to=self._state.head)
        super()._label('_st_label_1394', block=False)
        _st_label_1394 = 0
        while (_st_label_1394 == 0):
            _st_label_1394 += 1
            if (self._state.flag == 1):
                _st_label_1394 += 1
            else:
                super()._label('_st_label_1394', block=True)
                _st_label_1394 -= 1
        self._state.flag = 0

    def get_logger(self, name, filename):
        formatter = logging.Formatter(fmt='%(asctime)s %(levelname)-8s %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
        hld = logging.FileHandler(filename, mode='a')
        hld.setFormatter(formatter)
        self._state.logger = logging.getLogger(name)
        self._state.logger.setLevel(logging.DEBUG)
        self._state.logger.addHandler(hld)
        return self._state.logger

    def generateRequestId(self, opNum):
        requestID = ((str(self._id) + ';') + str(opNum))
        return requestID

    def getArguments(self, key_val):
        args_t = key_val.split(',')
        args = []
        for arg in args_t:
            arg = arg.strip()
            args.append(arg[1:(len(arg) - 1)])
        return args

    def getPseudorandomWL(self, seed, nOps):
        with open('words.txt') as f:
            words = f.read().splitlines()
        operations = ['put', 'get', 'append', 'slice']
        random.seed(seed)
        ind = [(x % 4) for x in random.sample(range((nOps * 2)), nOps)]
        listops = [operations[x] for x in ind]
        ind = [x for x in random.sample(range(20000), 12)]
        act_words = [words[x] for x in ind]
        self._state.workload = ''
        for op in listops:
            if (op == 'put'):
                str1 = act_words[random.randint(0, (len(act_words) - 1))]
                str2 = act_words[random.randint(0, (len(act_words) - 1))]
                self._state.workload = ((((((self._state.workload + ';') + "put('") + str1) + "','") + str2) + "')")
            elif (op == 'get'):
                str1 = act_words[random.randint(0, (len(act_words) - 1))]
                self._state.workload = ((((self._state.workload + ';') + "get('") + str1) + "')")
            elif (op == 'append'):
                str1 = act_words[random.randint(0, (len(act_words) - 1))]
                str2 = act_words[random.randint(0, (len(act_words) - 1))]
                self._state.workload = ((((((self._state.workload + ';') + "append('") + str1) + "','") + str2) + "')")
            elif (op == 'slice'):
                str1 = act_words[random.randint(0, (len(act_words) - 1))]
                num1 = random.randint(1, len(str1))
                num2 = random.randint(1, len(str1))
                if (num1 > num2):
                    str2 = ((str(num2) + ':') + str(num1))
                else:
                    str2 = ((str(num1) + ':') + str(num2))
                self._state.workload = ((((((self._state.workload + ';') + "slice('") + str1) + "','") + str2) + "')")
        self.output(self._state.workload.strip(';').split(';'))
        return self._state.workload.strip(';').split(';')

    def _Client_handler_1420(self, config, rkm, reps, olympus):
        self._state.replicas = reps
        self._state.head = list(reps)[0]
        self._state.replicaKM = rkm
        self._state.curr_config = config
        self.output(reps)
        self._state.logger.info((str(self._id) + ' Received new configuration'))
        self._state.logger.info(((str(self._id) + ' New head is : ') + str(self._state.head)))
        self._state.logger.info(((str(self._id) + ' Current Config is : ') + str(self._state.curr_config)))
        self._state.received_new_config = True
    _Client_handler_1420._labels = None
    _Client_handler_1420._notlabels = None

    def _Client_handler_1506(self, cKM, rKM, olympus):
        self._state.logger.info((str(self._id) + ' received public key map from olympus'))
        self._state.replicaKM = rKM
        self._state.clientKM = cKM
        self._state.flag = 1
    _Client_handler_1506._labels = None
    _Client_handler_1506._notlabels = None

    def _Client_handler_1544(self, resultShuttle, requestID, tail_id):
        self._state.logger.info(((str(self._id) + ' received result shuttle from :') + str(tail_id)))
        if ((requestID in self._state.RTRequest) == False):
            resultStatements = resultShuttle[requestID]
            i = 0
            for key in self._state.replicaKM:
                try:
                    self._state.replicaKM[key].verify(resultStatements[i])
                    i = (i + 1)
                except:
                    self._state.logger.info((str(self._id) + ' Result Statements are inconsistent. should send reconfiguration request to olympus'))
                    self.output('Received incosistent result shuttle from tail!!!')
                    return
            res = self._state.replicaKM[tail_id].verify(resultStatements[(i - 1)]).decode('utf-8').split(';')[1]
            self._state.logger.info(((((str(self._id) + ' the result for :') + requestID) + ' is ') + res))
            if (res == 'OK'):
                self.output('Put Successful')
        else:
            self._state.logger.info((str(self._id) + ' received old response'))
            self.output('received old responses')
        self._state.flag = (self._state.flag + 1)
    _Client_handler_1544._labels = None
    _Client_handler_1544._notlabels = None

    def _Client_handler_1686(self, resultShuttle, requestID, tail_id):
        self._state.logger.info(((str(self._id) + ' received result shuttle from :') + str(tail_id)))
        if ((requestID in self._state.RTRequest) == False):
            resultStatements = resultShuttle[requestID]
            i = 0
            for key in self._state.replicaKM:
                try:
                    self._state.replicaKM[key].verify(resultStatements[i])
                    i = (i + 1)
                except:
                    self._state.logger.info((str(self._id) + ' Result Statements are inconsistent. should send reconfiguration request to olympus'))
                    self.output("Result Statments received don't match, need reconfiguration")
                    break
            res = self._state.replicaKM[tail_id].verify(resultStatements[(i - 1)]).decode('utf-8').split(';')[1]
            self._state.logger.info(((((str(self._id) + ' the result for :') + requestID) + ' is ') + res))
            if (not (len(res) == 0)):
                self.output('Get Successful')
            else:
                self.output('Get unsuccessful. No such key in database.')
        else:
            self._state.logger.info((str(self._id) + ' received old response'))
            self.output('Old response received, dropping it')
        self._state.flag = (self._state.flag + 1)
    _Client_handler_1686._labels = None
    _Client_handler_1686._notlabels = None

    def _Client_handler_1832(self, resultShuttle, requestID, tail_id):
        self._state.logger.info(((str(self._id) + ' received result shuttle from :') + str(tail_id)))
        if ((requestID in self._state.RTRequest) == False):
            resultStatements = resultShuttle[requestID]
            i = 0
            for key in self._state.replicaKM:
                try:
                    self._state.replicaKM[key].verify(resultStatements[i])
                    i = (i + 1)
                except:
                    self._state.logger.info((str(self._id) + ' Result Statements are inconsistent. should send reconfiguration request to olympus'))
                    self.output("Result Statments received don't match, need reconfiguration")
                    break
            res = self._state.replicaKM[tail_id].verify(resultStatements[(i - 1)]).decode('utf-8').split(';')[1]
            self._state.logger.info(((((str(self._id) + ' the result for :') + requestID) + ' is ') + res))
            if (res == 'OK'):
                self.output('Slice was successful')
            else:
                self.output('Slice was unsuccessful')
        else:
            self._state.logger.info((str(self._id) + ' received old response'))
            self.output('Old response received, dropping it')
        self._state.flag = (self._state.flag + 1)
    _Client_handler_1832._labels = None
    _Client_handler_1832._notlabels = None

    def _Client_handler_1976(self, resultShuttle, requestID, tail_id):
        self._state.logger.info(((str(self._id) + ' received result shuttle from :') + str(tail_id)))
        if ((requestID in self._state.RTRequest) == False):
            resultStatements = resultShuttle[requestID]
            i = 0
            for key in self._state.replicaKM:
                try:
                    self._state.replicaKM[key].verify(resultStatements[i])
                    i = (i + 1)
                except:
                    self._state.logger.info((str(self._id) + ' Result Statements are inconsistent. should send reconfiguration request to olympus'))
                    self.output("Result Statments received don't match, need reconfiguration")
                    break
            res = self._state.replicaKM[tail_id].verify(resultStatements[(i - 1)]).decode('utf-8').split(';')[1]
            self._state.logger.info(((((str(self._id) + ' the result for :') + requestID) + ' is ') + res))
            if (res == 'OK'):
                self.output('Append was successful')
            else:
                self.output('Append was unsuccessful')
        else:
            self.output('Old response received, dropping it')
        self._state.flag = (self._state.flag + 1)
    _Client_handler_1976._labels = None
    _Client_handler_1976._notlabels = None

    def _Client_handler_2111(self, replicas, olympus_id):
        self._state.replicas = replicas
    _Client_handler_2111._labels = None
    _Client_handler_2111._notlabels = None

    def _Client_handler_2128(self, db, p_id):
        self._state.logger.info(((str(self._id) + 'The final state is: ') + str(db)))
        self.output('Current State: ', db)
        self._state.flag = (self._state.flag + 1)
    _Client_handler_2128._labels = None
    _Client_handler_2128._notlabels = None

    def _Client_handler_2161(self, pri_key, oly):
        self._state.private_key = pri_key
        self._state.flag = 1
    _Client_handler_2161._labels = None
    _Client_handler_2161._notlabels = None

    def _Client_handler_2183(self, req_id, rid):
        self._state.reconfig = True
        self._state.reconfig_at = req_id
        self._state.logger.info((str(self._id) + ' Received immutable message from replica. Reconfig is underway.'))
    _Client_handler_2183._labels = None
    _Client_handler_2183._notlabels = None
