# -*- generated by 1.0.9 -*-
import da
PatternExpr_1072 = da.pat.TuplePattern([da.pat.ConstantPattern('public_key_maps'), da.pat.FreePattern('cKM'), da.pat.FreePattern('rKM')])
PatternExpr_1081 = da.pat.FreePattern('olympus')
PatternExpr_1110 = da.pat.TuplePattern([da.pat.ConstantPattern('put_result'), da.pat.FreePattern('resultShuttle'), da.pat.FreePattern('requestID')])
PatternExpr_1119 = da.pat.FreePattern('tail_id')
PatternExpr_1252 = da.pat.TuplePattern([da.pat.ConstantPattern('get_result'), da.pat.FreePattern('resultShuttle'), da.pat.FreePattern('requestID')])
PatternExpr_1261 = da.pat.FreePattern('tail_id')
PatternExpr_1398 = da.pat.TuplePattern([da.pat.ConstantPattern('slice_result'), da.pat.FreePattern('resultShuttle'), da.pat.FreePattern('requestID')])
PatternExpr_1407 = da.pat.FreePattern('tail_id')
PatternExpr_1542 = da.pat.TuplePattern([da.pat.ConstantPattern('append_result'), da.pat.FreePattern('resultShuttle'), da.pat.FreePattern('requestID')])
PatternExpr_1551 = da.pat.FreePattern('tail_id')
PatternExpr_1677 = da.pat.TuplePattern([da.pat.ConstantPattern('currentConfig'), da.pat.FreePattern('replicas')])
PatternExpr_1683 = da.pat.FreePattern('olympus_id')
PatternExpr_1694 = da.pat.TuplePattern([da.pat.ConstantPattern('dict_reply'), da.pat.FreePattern('db')])
PatternExpr_1701 = da.pat.FreePattern('p_id')
PatternExpr_1727 = da.pat.TuplePattern([da.pat.ConstantPattern('generated_key'), da.pat.FreePattern('pri_key')])
PatternExpr_1734 = da.pat.FreePattern('oly')
PatternExpr_1749 = da.pat.TuplePattern([da.pat.ConstantPattern('immutable'), da.pat.FreePattern('req_id')])
PatternExpr_1756 = da.pat.FreePattern('rid')
_config_object = {}
import random
import time
import sys
import logging
replica = da.import_da('Replica')
olympus = da.import_da('Olympus')

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_1072, sources=[PatternExpr_1081], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1071]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_1110, sources=[PatternExpr_1119], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1109]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_1252, sources=[PatternExpr_1261], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1251]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_1398, sources=[PatternExpr_1407], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1397]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_1542, sources=[PatternExpr_1551], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1541]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_5', PatternExpr_1677, sources=[PatternExpr_1683], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1676]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_6', PatternExpr_1694, sources=[PatternExpr_1701], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1693]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_7', PatternExpr_1727, sources=[PatternExpr_1734], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1726]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_8', PatternExpr_1749, sources=[PatternExpr_1756], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1748])])

    def setup(self, conf, oly, workload, cc, **rest_2115):
        super().setup(conf=conf, oly=oly, workload=workload, cc=cc, **rest_2115)
        self._state.conf = conf
        self._state.oly = oly
        self._state.workload = workload
        self._state.cc = cc
        self._state.replicas = {}
        self._state.flag = 0
        self._state.RTRequest = []
        self._state.private_key = ''
        self._state.replicaKM = {}
        self._state.clientKM = {}
        self._state.logger = None
        self._state.curr_config = self._state.cc
        self._state.reconfig = False
        self._state.reconfig_at = None

    def run(self):
        logger_file_name = ((self._state.conf['test_case_name'] + str(self._id).split(':')[1]) + '_c.txt')
        self._state.logger = self.get_logger('client', logger_file_name)
        self._state.logger.info((str(self._id) + ' sending get config request to olympus'))
        self.send(('getConfig', self._id), to=self._state.oly)
        super()._label('_st_label_337', block=False)
        _st_label_337 = 0
        while (_st_label_337 == 0):
            _st_label_337 += 1
            if (not (len(self._state.replicas) == 0)):
                _st_label_337 += 1
            else:
                super()._label('_st_label_337', block=True)
                _st_label_337 -= 1
        self._state.logger.info((str(self._id) + ' sending generate key request to olympus'))
        self.send('generate_keys', to=self._state.oly)
        super()._label('_st_label_359', block=False)
        _st_label_359 = 0
        while (_st_label_359 == 0):
            _st_label_359 += 1
            if (self._state.flag == 1):
                _st_label_359 += 1
            else:
                super()._label('_st_label_359', block=True)
                _st_label_359 -= 1
        self._state.flag = 0
        self._state.logger.info((str(self._id) + ' getting public key map from olympus'))
        self.send('get_public_key_maps', to=self._state.oly)
        super()._label('_st_label_384', block=False)
        _st_label_384 = 0
        while (_st_label_384 == 0):
            _st_label_384 += 1
            if (self._state.flag == 1):
                _st_label_384 += 1
            else:
                super()._label('_st_label_384', block=True)
                _st_label_384 -= 1
        self._state.flag = 0
        self._state.logger.info(((str(self._id) + ' the workload is : ') + str(self._state.workload)))
        self.output(' The workload is: ', self._state.workload)
        if (self._state.workload[0][0:6] == 'pseudo'):
            self._state.logger.info((str(self._id) + ' generating the pseudo random workload'))
            key_val = self._state.workload[0][13:(len(self._state.workload[0]) - 1)]
            seed = int(key_val.split(',')[0])
            opn = int(key_val.split(',')[1])
            self._state.workload = self.getPseudorandomWL(seed, opn)
            self.output(self._state.workload)
        rep = list(self._state.replicas)
        head = rep[0]
        opNum = 0
        for op in self._state.workload:
            op_b = op[0:3]
            if (op_b == 'put'):
                key_val = op[4:(len(op) - 1)]
                args = self.getArguments(key_val)
                self._state.logger.info((((str(self._id) + ' sending put operation with ') + str(key_val)) + ' to head'))
                self.send(('put', args, self._id, self.generateRequestId(opNum)), to=head)
                i = 0
                j = 0
                while (j < 2):
                    super()._label('_st_label_564', block=False)
                    _st_label_564 = 0
                    self._timer_start()
                    while (_st_label_564 == 0):
                        _st_label_564 += 1
                        if ((self._state.flag == 1) or (self._state.reconfig == True)):
                            self._state.flag = 0
                            break
                            _st_label_564 += 1
                        elif self._timer_expired:
                            self._state.logger.info((str(self._id) + ' Operation timeout. Broadcasting to all clients'))
                            self.output('Operation TimedOut. Broadcasting message to all clients')
                            self._state.RTRequest.append(self.generateRequestId(opNum))
                            for r in self._state.replicas:
                                self.send(('put', args, self._id, self.generateRequestId(opNum)), to=r)
                            j = (j + 1)
                            _st_label_564 += 1
                        else:
                            super()._label('_st_label_564', block=True, timeout=(self._state.conf['client_timeout'] / 1000))
                            _st_label_564 -= 1
                    else:
                        if (_st_label_564 != 2):
                            continue
                    if (_st_label_564 != 2):
                        break
                    i = (i + 1)
            elif (op_b == 'get'):
                key = op[4:(len(op) - 1)]
                args = self.getArguments(key)
                self._state.logger.info((((str(self._id) + ' sending get operation with ') + args[0]) + ' to head'))
                self.send(('get', args[0], self._id, self.generateRequestId(opNum)), to=head)
                i = 0
                j = 0
                while (j < 2):
                    super()._label('_st_label_690', block=False)
                    _st_label_690 = 0
                    self._timer_start()
                    while (_st_label_690 == 0):
                        _st_label_690 += 1
                        if ((self._state.flag == 1) or (self._state.reconfig == True)):
                            self._state.flag = 0
                            break
                            _st_label_690 += 1
                        elif self._timer_expired:
                            self._state.logger.info((str(self._id) + ' Operation timeout. Broadcasting to all clients'))
                            self.output('Operation TimedOut. Broadcasting message to all clients')
                            self._state.RTRequest.append(self.generateRequestId(opNum))
                            for r in self._state.replicas:
                                self.send(('get', args[0], self._id, self.generateRequestId(opNum)), to=r)
                            j = (j + 2)
                            _st_label_690 += 1
                        else:
                            super()._label('_st_label_690', block=True, timeout=(self._state.conf['client_timeout'] / 1000))
                            _st_label_690 -= 1
                    else:
                        if (_st_label_690 != 2):
                            continue
                    if (_st_label_690 != 2):
                        break
                    i = (i + 1)
            elif (op_b == 'sli'):
                key_val = op[6:(len(op) - 1)]
                args = self.getArguments(key_val)
                self._state.logger.info((((str(self._id) + ' sending slice operation with ') + str(args)) + ' to head'))
                self.send(('slice', args, self._id, self.generateRequestId(opNum)), to=head)
                i = 0
                j = 0
                while (j < 2):
                    super()._label('_st_label_814', block=False)
                    _st_label_814 = 0
                    self._timer_start()
                    while (_st_label_814 == 0):
                        _st_label_814 += 1
                        if ((self._state.flag == 1) or (self._state.reconfig == True)):
                            self._state.flag = 0
                            break
                            _st_label_814 += 1
                        elif self._timer_expired:
                            self._state.logger.info((str(self._id) + ' Operation timeout. Broadcasting to all clients'))
                            self.output('Operation TimedOut. Broadcasting message to all clients')
                            self._state.RTRequest.append(self.generateRequestId(opNum))
                            for r in self._state.replicas:
                                self.send(('slice', args, self._id, self.generateRequestId(opNum)), to=r)
                            j = (j + 2)
                            _st_label_814 += 1
                        else:
                            super()._label('_st_label_814', block=True, timeout=(self._state.conf['client_timeout'] / 1000))
                            _st_label_814 -= 1
                    else:
                        if (_st_label_814 != 2):
                            continue
                    if (_st_label_814 != 2):
                        break
                    i = (i + 1)
            elif (op_b == 'app'):
                key_val = op[7:(len(op) - 1)]
                args = self.getArguments(key_val)
                self._state.logger.info((((str(self._id) + ' sending append operation with ') + str(args)) + ' to head'))
                self.send(('append', args, self._id, self.generateRequestId(opNum)), to=head)
                i = 0
                j = 0
                while (j < 2):
                    super()._label('_st_label_936', block=False)
                    _st_label_936 = 0
                    self._timer_start()
                    while (_st_label_936 == 0):
                        _st_label_936 += 1
                        if ((self._state.flag == 1) or (self._state.reconfig == True)):
                            self._state.flag = 0
                            break
                            _st_label_936 += 1
                        elif self._timer_expired:
                            self._state.logger.info((str(self._id) + ' Operation timeout. Broadcasting to all clients'))
                            self.output('Operation TimedOut. Broadcasting message to all clients')
                            self._state.RTRequest.append(self.generateRequestId(opNum))
                            for r in self._state.replicas:
                                self.send(('append', args, self._id, self.generateRequestId(opNum)), to=r)
                            j = (j + 2)
                            _st_label_936 += 1
                        else:
                            super()._label('_st_label_936', block=True, timeout=(self._state.conf['client_timeout'] / 1000))
                            _st_label_936 -= 1
                    else:
                        if (_st_label_936 != 2):
                            continue
                    if (_st_label_936 != 2):
                        break
                    i = (i + 1)
            elif (op_b == 'rec'):
                self.send('reconfig', to=head)
                super()._label('_st_label_1012', block=False)
                _st_label_1012 = 0
                while (_st_label_1012 == 0):
                    _st_label_1012 += 1
                    if ((self._state.flag == 1) or (self._state.reconfig == True)):
                        self._state.flag = 0
                        _st_label_1012 += 1
                    else:
                        super()._label('_st_label_1012', block=True)
                        _st_label_1012 -= 1
                else:
                    if (_st_label_1012 != 2):
                        continue
                if (_st_label_1012 != 2):
                    break
            if (self._state.reconfig == True):
                self.output('Reconfiguration is underway. Ask olympus for reconfig request')
            opNum = (opNum + 1)
        self.send('get_dict', to=head)
        super()._label('_st_label_1045', block=False)
        _st_label_1045 = 0
        while (_st_label_1045 == 0):
            _st_label_1045 += 1
            if (self._state.flag == 1):
                _st_label_1045 += 1
            else:
                super()._label('_st_label_1045', block=True)
                _st_label_1045 -= 1
        self._state.flag = 0

    def get_logger(self, name, filename):
        formatter = logging.Formatter(fmt='%(asctime)s %(levelname)-8s %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
        hld = logging.FileHandler(filename, mode='a')
        hld.setFormatter(formatter)
        self._state.logger = logging.getLogger(name)
        self._state.logger.setLevel(logging.DEBUG)
        self._state.logger.addHandler(hld)
        return self._state.logger

    def generateRequestId(self, opNum):
        requestID = ((str(self._id) + ';') + str(opNum))
        return requestID

    def getArguments(self, key_val):
        args_t = key_val.split(',')
        args = []
        for arg in args_t:
            arg = arg.strip()
            args.append(arg[1:(len(arg) - 1)])
        return args

    def getPseudorandomWL(self, seed, nOps):
        with open('words.txt') as f:
            words = f.read().splitlines()
        operations = ['put', 'get', 'append', 'slice']
        random.seed(seed)
        ind = [(x % 4) for x in random.sample(range((nOps * 2)), nOps)]
        listops = [operations[x] for x in ind]
        ind = [x for x in random.sample(range(20000), 12)]
        act_words = [words[x] for x in ind]
        self._state.workload = ''
        for op in listops:
            if (op == 'put'):
                str1 = act_words[random.randint(0, (len(act_words) - 1))]
                str2 = act_words[random.randint(0, (len(act_words) - 1))]
                self._state.workload = ((((((self._state.workload + ';') + "put('") + str1) + "','") + str2) + "')")
            elif (op == 'get'):
                str1 = act_words[random.randint(0, (len(act_words) - 1))]
                self._state.workload = ((((self._state.workload + ';') + "get('") + str1) + "')")
            elif (op == 'append'):
                str1 = act_words[random.randint(0, (len(act_words) - 1))]
                str2 = act_words[random.randint(0, (len(act_words) - 1))]
                self._state.workload = ((((((self._state.workload + ';') + "append('") + str1) + "','") + str2) + "')")
            elif (op == 'slice'):
                str1 = act_words[random.randint(0, (len(act_words) - 1))]
                num1 = random.randint(1, len(str1))
                num2 = random.randint(1, len(str1))
                if (num1 > num2):
                    str2 = ((str(num2) + ':') + str(num1))
                else:
                    str2 = ((str(num1) + ':') + str(num2))
                self._state.workload = ((((((self._state.workload + ';') + "slice('") + str1) + "','") + str2) + "')")
        self.output(self._state.workload.strip(';').split(';'))
        return self._state.workload.strip(';').split(';')

    def _Client_handler_1071(self, cKM, rKM, olympus):
        self._state.logger.info((str(self._id) + ' received public key map from olympus'))
        self._state.replicaKM = rKM
        self._state.clientKM = cKM
        self._state.flag = 1
    _Client_handler_1071._labels = None
    _Client_handler_1071._notlabels = None

    def _Client_handler_1109(self, resultShuttle, requestID, tail_id):
        self._state.logger.info(((str(self._id) + ' received result shuttle from :') + str(tail_id)))
        if ((requestID in self._state.RTRequest) == False):
            resultStatements = resultShuttle[requestID]
            i = 0
            for key in self._state.replicaKM:
                try:
                    self._state.replicaKM[key].verify(resultStatements[i])
                    i = (i + 1)
                except:
                    self._state.logger.info((str(self._id) + ' Result Statements are inconsistent. should send reconfiguration request to olympus'))
                    self.output('Received incosistent result shuttle from tail!!!')
                    return
            res = self._state.replicaKM[tail_id].verify(resultStatements[(i - 1)]).decode('utf-8').split(';')[1]
            self._state.logger.info(((((str(self._id) + ' the result for :') + requestID) + ' is ') + res))
            if (res == 'OK'):
                self.output('Put Successful')
        else:
            self._state.logger.info((str(self._id) + ' received old response'))
            self.output('received old responses')
        self._state.flag = (self._state.flag + 1)
    _Client_handler_1109._labels = None
    _Client_handler_1109._notlabels = None

    def _Client_handler_1251(self, resultShuttle, requestID, tail_id):
        self._state.logger.info(((str(self._id) + ' received result shuttle from :') + str(tail_id)))
        if ((requestID in self._state.RTRequest) == False):
            resultStatements = resultShuttle[requestID]
            i = 0
            for key in self._state.replicaKM:
                try:
                    self._state.replicaKM[key].verify(resultStatements[i])
                    i = (i + 1)
                except:
                    self._state.logger.info((str(self._id) + ' Result Statements are inconsistent. should send reconfiguration request to olympus'))
                    self.output("Result Statments received don't match, need reconfiguration")
                    break
            res = self._state.replicaKM[tail_id].verify(resultStatements[(i - 1)]).decode('utf-8').split(';')[1]
            self._state.logger.info(((((str(self._id) + ' the result for :') + requestID) + ' is ') + res))
            if (not (len(res) == 0)):
                self.output('Get Successful')
            else:
                self.output('Get unsuccessful. No such key in database.')
        else:
            self._state.logger.info((str(self._id) + ' received old response'))
            self.output('Old response received, dropping it')
        self._state.flag = (self._state.flag + 1)
    _Client_handler_1251._labels = None
    _Client_handler_1251._notlabels = None

    def _Client_handler_1397(self, resultShuttle, requestID, tail_id):
        self._state.logger.info(((str(self._id) + ' received result shuttle from :') + str(tail_id)))
        if ((requestID in self._state.RTRequest) == False):
            resultStatements = resultShuttle[requestID]
            i = 0
            for key in self._state.replicaKM:
                try:
                    self._state.replicaKM[key].verify(resultStatements[i])
                    i = (i + 1)
                except:
                    self._state.logger.info((str(self._id) + ' Result Statements are inconsistent. should send reconfiguration request to olympus'))
                    self.output("Result Statments received don't match, need reconfiguration")
                    break
            res = self._state.replicaKM[tail_id].verify(resultStatements[(i - 1)]).decode('utf-8').split(';')[1]
            self._state.logger.info(((((str(self._id) + ' the result for :') + requestID) + ' is ') + res))
            if (res == 'OK'):
                self.output('Slice was successful')
            else:
                self.output('Slice was unsuccessful')
        else:
            self._state.logger.info((str(self._id) + ' received old response'))
            self.output('Old response received, dropping it')
        self._state.flag = (self._state.flag + 1)
    _Client_handler_1397._labels = None
    _Client_handler_1397._notlabels = None

    def _Client_handler_1541(self, resultShuttle, requestID, tail_id):
        self._state.logger.info(((str(self._id) + ' received result shuttle from :') + str(tail_id)))
        if ((requestID in self._state.RTRequest) == False):
            resultStatements = resultShuttle[requestID]
            i = 0
            for key in self._state.replicaKM:
                try:
                    self._state.replicaKM[key].verify(resultStatements[i])
                    i = (i + 1)
                except:
                    self._state.logger.info((str(self._id) + ' Result Statements are inconsistent. should send reconfiguration request to olympus'))
                    self.output("Result Statments received don't match, need reconfiguration")
                    break
            res = self._state.replicaKM[tail_id].verify(resultStatements[(i - 1)]).decode('utf-8').split(';')[1]
            self._state.logger.info(((((str(self._id) + ' the result for :') + requestID) + ' is ') + res))
            if (res == 'OK'):
                self.output('Append was successful')
            else:
                self.output('Append was unsuccessful')
        else:
            self.output('Old response received, dropping it')
        self._state.flag = (self._state.flag + 1)
    _Client_handler_1541._labels = None
    _Client_handler_1541._notlabels = None

    def _Client_handler_1676(self, replicas, olympus_id):
        self._state.replicas = replicas
    _Client_handler_1676._labels = None
    _Client_handler_1676._notlabels = None

    def _Client_handler_1693(self, db, p_id):
        self._state.logger.info(((str(self._id) + 'The final state is: ') + str(db)))
        self.output('Current State: ', db)
        self._state.flag = (self._state.flag + 1)
    _Client_handler_1693._labels = None
    _Client_handler_1693._notlabels = None

    def _Client_handler_1726(self, pri_key, oly):
        self._state.private_key = pri_key
        self._state.flag = 1
    _Client_handler_1726._labels = None
    _Client_handler_1726._notlabels = None

    def _Client_handler_1748(self, req_id, rid):
        self._state.reconfig = True
        self._state.reconfig_at = req_id
        self._state.logger.info((str(self._id) + ' Received immutable message from replica. Reconfig is underway.'))
    _Client_handler_1748._labels = None
    _Client_handler_1748._notlabels = None
