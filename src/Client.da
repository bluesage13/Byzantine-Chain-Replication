import random
replica = import_da('Replica')
olympus = import_da('Olympus')

class Client(process):

  def setup(conf, oly, workload):
    self.replicas = {}
    self.flag = 0
    self.RTRequest = []
    self.private_key = ""
    self.replicaKM = {}
    self.clientKM = {}

  def run():
    send(('getConfig', self), to = oly)
    await(len(self.replicas) != 0)
    send(('generate_keys'), to = oly)
    await(self.flag == 1)
    self.flag = 0
    send(('get_public_key_maps'), to = oly)
    await(self.flag == 1)
    self.flag = 0
    output (" The workload is: ", workload)
    if(workload[0][0:6] == 'pseudo'):
      key_val = workload[0][13:(len(workload[0])-1)]
      seed = int(key_val.split(',')[0])
      opn = int(key_val.split(',')[1])
      workload = getPseudorandomWL(seed, opn)

    rep = list(self.replicas)
    head = rep[0]
    opNum = 0
    for op in workload:
      op_b = op[0:3]
      if(op_b == 'put'):
        key_val = op[4:(len(op)-1)]
        args = getArguments(key_val)
        send(('put', args, self, generateRequestId(opNum)), to = head)
        while(True):
          if await(flag == 1):
            self.flag = 0
            break
          elif timeout(conf['client_timeout']/1000):
            output("Operation TimedOut. Broadcasting message to all clients")
            self.RTRequest.append(generateRequestId(opNum))
            for r in self.replicas:
              send(('put', args, self, generateRequestId(opNum)), to = r)


      elif(op_b == 'get'):
        key = op[4:(len(op)-1)]
        args = getArguments(key)
        send(('get', (args[0]), self, generateRequestId(opNum)), to = head)
        await(flag == 1)
        self.flag = 0

      elif(op_b == 'sli'):
        key_val = op[6:(len(op)-1)]
        args = getArguments(key_val)
        send(('slice', args, self, generateRequestId(opNum)), to = head)
        await(flag == 1)
        self.flag = 0

      elif(op_b == 'app'):
        key_val = op[7:(len(op)-1)]
        args = getArguments(key_val)
        send(('append', args, self, generateRequestId(opNum)), to = head)
        await(flag == 1)
        self.flag = 0

      opNum = opNum + 1



    send(('get_dict'), to = head)
    await(flag == 1)
    flag = 0

  def generateRequestId(opNum):
    requestID = str(self) + ';' + str(opNum)
    return requestID

  def receive(msg = ('public_key_maps', cKM, rKM), from_ = olympus):
    self.replicaKM = rKM
    self.clientKM = cKM
    self.flag = 1

  def receive(msg=('put_result', resultShuttle ,requestID), from_=tail_id):
    if((requestID in self.RTRequest) == False):
      resultStatements = resultShuttle[requestID]
      i = 0
      for key in self.replicaKM:
        try:
          self.replicaKM[key].verify(resultStatements[i])
          i = i + 1
        except:
          output("Something is wrongs")

      res = self.replicaKM[tail_id].verify(resultStatements[i-1]).decode('utf-8').split(';')[1]
      if(res == 'OK'):
        output("Put Successful")

    else:
      output("Old response received, dropping it")
    flag = flag + 1

  def receive(msg=('get_result', resultShuttle ,requestID), from_=tail_id):
    if((requestID in self.RTRequest) == False):
      resultStatements = resultShuttle[requestID]
      i = 0
      for key in self.replicaKM:
        try:
          self.replicaKM[key].verify(resultStatements[i])
          i = i + 1
        except:
          output("Result Statments received don't match, need reconfiguration")
          break

      res = self.replicaKM[tail_id].verify(resultStatements[i-1]).decode('utf-8').split(';')[1]
      if(res == 'OK'):
        output("Get Successful")
      else:
        output("Get unsuccessful. No such key in database.")

    else:
      output("Old response received, dropping it")
    flag = flag + 1

  def receive(msg=('slice_result', resultShuttle ,requestID), from_=tail_id):
    if((requestID in self.RTRequest) == False):
      resultStatements = resultShuttle[requestID]
      i = 0
      for key in self.replicaKM:
        try:
          self.replicaKM[key].verify(resultStatements[i])
          i = i + 1
        except:
          output("Something is wrongs")
      res = self.replicaKM[tail_id].verify(resultStatements[i-1]).decode('utf-8').split(';')[1]
      if(res == 'OK'):
        output("Slice was successful")
      else:
        output("Slice was unsuccessful")
    else:
      output("Old response received, dropping it")
    flag = flag + 1

  def receive(msg=('append_result', resultShuttle ,requestID), from_=tail_id):
    if((requestID in self.RTRequest) == False):
      resultStatements = resultShuttle[requestID]
      i = 0
      for key in self.replicaKM:
        try:
          self.replicaKM[key].verify(resultStatements[i])
          i = i + 1
        except:
          output("Something is wrongs")
      res = self.replicaKM[tail_id].verify(resultStatements[i-1]).decode('utf-8').split(';')[1]
      if(res == 'OK'):
        output("Append was successful")
      else:
        output("Append was unsuccessful")
    else:
      output("Old response received, dropping it")
    flag = flag + 1

  def receive(msg=('currentConfig', replicas), from_=olympus_id):
    self.replicas = replicas

  def receive(msg = ('dict_reply', db), from_ = p_id):
    output("Current State: ", db)
    flag = flag + 1

  def receive(msg = ('generated_key', pri_key), from_ = oly):
    self.private_key = pri_key
    self.flag = 1

  def getArguments(key_val):
    args_t = key_val.split(',')
    args = []
    for arg in args_t:
      arg = arg.strip()
      args.append(arg[1:(len(arg)-1)])
    return args

  def getPseudorandomWL(seed, nOps):
    with open("words.txt") as f:
      words = f.read().splitlines()
    operations = ['put', 'get', 'append', 'slice']
    random.seed(seed)
    ind = [x%4 for x in random.sample(range(nOps * 2), nOps)]
    listops = [operations[x] for x in ind]
    ind = [x for x in random.sample(range(20000), 12)]
    act_words = [words[x] for x in ind]
    #random.seed(None)
    workload = ""
    for op in listops:
        if(op == 'put'):
            str1 = act_words[random.randint(0,len(act_words) - 1)]
            str2 = act_words[random.randint(0,len(act_words) - 1)]
            workload = workload + ";" + "put('" + str1 + "','" + str2 + "')"
        elif(op == 'get'):
            str1 = act_words[random.randint(0,len(act_words) - 1)]
            workload = workload + ";" + "get('" + str1 + "')"
        elif(op == 'append'):
            str1 = act_words[random.randint(0,len(act_words) - 1)]
            str2 = act_words[random.randint(0,len(act_words) - 1)]
            workload = workload + ";" + "append('" + str1 + "','" + str2 + "')"
        elif(op == 'slice'):
            str1 = act_words[random.randint(0,len(act_words) - 1)]
            num1 = random.randint(1, len(str1))
            num2 = random.randint(1, len(str1))
            if num1 > num2 : str2 = str(num2) +":"+ str(num1)
            else: str2 = str(num1) +":"+ str(num2)
            workload = workload + ";" + "slice('" + str1 + "','" + str2 + "')"
    output(workload.strip(';').split(';'))
    return workload.strip(';').split(';')
